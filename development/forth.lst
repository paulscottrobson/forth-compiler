              	; --------------------------------------
              	; zasm: assemble "forth.asm"
              	; date: 2017-05-15 18:45:48
              	; --------------------------------------


              	; ****************************************************************************************************
              	;
              	;									Forth Compiler Runtime
              	;
              	; ****************************************************************************************************
              	
              		include 	"sna_header.asm"			; .SNA boot header
              	; *****************************************************************************************
              	; *****************************************************************************************
              	;
              	;                       SNA Header - variant of the provided example.
              	;
              	; *****************************************************************************************
              	; *****************************************************************************************
              	
              	#target sna
              	
              	; *****************************************************************************************
              	;
              	;                               saved registers, restored in NMI
              	;
              	; *****************************************************************************************
              	
0000:         	#code HEAD, 0, 27
0000: 3F      	    defb    $3f             ; i
0001: 0000    	    defw    0               ; hl'
0003: 0000    	    defw    0               ; de'
0005: 0000    	    defw    0               ; bc'
0007: 0000    	    defw    0               ; af'
              	
0009: 0000    	    defw    0               ; hl
000B: 0000    	    defw    0               ; de
000D: 0000    	    defw    0               ; bc
000F: 0000    	    defw    0               ; iy
0011: 0000    	    defw    0               ; ix
              	
0013: 00      	    defb    0<<2            ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei
0014: 000000  	    defb    0,0,0           ; r,f,a
0017: 035B    	    defw    __stackEnd      ; sp
0019: 01      	    defb    1               ; irpt mode
001A: 00      	    defb    0               ; border color: 0=black ... 7=white
              	
              	; *****************************************************************************************
              	;
              	;                   $4000-$7FFF. Pixel Memory, Attribute Memory, Slow RAM
              	;
              	; *****************************************************************************************
              	
4000:         	#code SLOW_RAM, 0x4000, 0x4000
              	
4000:         	VideoMemory:
4000: 00000000	    defs    0x1800
4004: 00...   	
5800:         	AttributeMemory:
5800: 00000000	    defs    0x300
5804: 00...   	
5B00:         	EndVideoMemory:
              	
5B00:         	__bootSNA:
5B00: C30480  	    jp      start
              	
              	; *****************************************************************************************
              	;
              	;                            $8000-$FFFF. Non contentious memory
              	;
              	; *****************************************************************************************
              	
5B03:         	__stackEnd:   
5B03: 005B    	    defw    __bootSNA
              	
8000:         	#code FAST_RAM, 0x8000, 0x8000
              	
              		include 	"core4.asm" 				; Forth core (Direct Threaded)
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;													Core v4
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;	These words are accessed/changed by the compiler, so it knows (i) where to start the program
              	;	and (ii) where it can compile code.
              	;
              	; ****************************************************************************************************
              	
8000:         	BootAddress:
8000: CB83    		defw 	BootWord 						; start of threaded word.
8002:         	FreeAddress:
8002: EE83    		defw 	EndOfCode 						; end of code that is built with the assembler.
              	
              	; ****************************************************************************************************
              	;
              	;										Start Forth Core
              	;
              	; ****************************************************************************************************
              		
8004:         	start:
8004: DD212280		ld 		ix,Core_Continue  				; these allow us to do fast jumps in and out of routines.
8008: FD211980		ld 		iy,Core_Call 					; also saving a byte on long jumps.
              	
800C: 310000  		ld 		sp,0x0000 						; sp is the data stack (works down)
800F: 0100FF  		ld 		bc,0xFF00 						; bc is the return stack (works up)
              	
8012: 2A0080  		ld 		hl,(BootAddress)				; hl is the IP (except when executing Z80 code words)
8015: 23      		inc 	hl 								; skip over the JP (IY)
8016: 23      		inc 	hl
8017: 180A    		jr 		Core_Execute
              	
              	; ****************************************************************************************************
              	;
              	;		The JP (IY) at the start of a threaded definition comes here. DE contains
              	; 		the old address, HL the new one.
              	;
              	;		Save the calling address on the stack and execute from HL. Which handily is in HL.
              	;
              	; ****************************************************************************************************
              	
8019:         	Core_Call:
8019: 23      		inc 	hl 								; advance HL over the JP(IY) $FD $E9
801A: 23      		inc 	hl 								; now points to the first definition
              	
801B: 7B      		ld 		a,e 							; push DE (old address) on the BC stack.
801C: 03      		inc 	bc 								; unfortunately a Z80 only has one stack, so we have
801D: 02      		ld 		(bc),a 							; to use it for either data *or* return.
801E: 7A      		ld 		a,d
801F: 03      		inc 	bc
8020: 02      		ld 		(bc),a
              	
8021: EB      		ex 		de,hl 							; allows us to fall through to execute loop
              	
              	; ****************************************************************************************************
              	;
              	;	Ending a machine code definition comes here (using JP (IX)). We need this exchange
              	; 	because when running m/c definition DE is the instruction pointer
              	;
              	; ****************************************************************************************************
              	
8022:         	Core_Continue:
8022: EB      		ex 		de,hl 							; if executing code word come back here.
              	
              	; ****************************************************************************************************
              	;
              	;					Main execution entry point. Execute instruction at (DE)
              	;
              	; ****************************************************************************************************
              	
8023:         	Core_Execute:
8023: 5E      		ld 		e,(hl)							; read address of next word at HL into DE, LSB first
8024: 23      		inc 	hl
8025: 56      		ld 		d,(hl)
8026: 23      		inc 	hl
8027: EB      		ex 		de,hl 							; swap so when executing code word DE code ptr and so we can 
8028: E9      		jp 		(hl) 							; do this 4 cycle jump
              	
              	; ****************************************************************************************************
              	;
              	;											16 bit literal word
              	;
              	; ****************************************************************************************************
              	
8029:         	Core_Literal:								; <<.literal>>
8029: EB      		ex 		de,hl 							; HL now contains the IP back again.
802A: 5E      		ld 		e,(hl) 							; load next word into DE
802B: 23      		inc 	hl
802C: 56      		ld 		d,(hl)
802D: 23      		inc 	hl
802E: D5      		push 	de 								; push word on data stack
802F: 18F2    		jr 		Core_Execute 					; and execute without doing the DE/HL swap
              	
              	; ****************************************************************************************************
              	;
              	;												Return word.
              	;
              	; ****************************************************************************************************
              	
8031:         	Core_Return:								; <<;>>
8031: 0A      		ld 		a,(bc) 							; pop address into DE.
8032: 0B      		dec 	bc
8033: 57      		ld 		d,a 
8034: 0A      		ld 		a,(bc)
8035: 0B      		dec 	bc
8036: 5F      		ld 		e,a
8037: DDE9    		jp 		(ix) 							; this will put DE -> HL and start executing one level up.
              	
              		include 	"library.asm" 				; Basic FORTH words including optional text/sprite stuff
              	; ****************************************************************************************************
              	;
              	;								 Basic FORTH Library, Z80 Assembler
              	;
              	; ****************************************************************************************************
              	
              		include "library/binary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Binary)
              	;
              	; ****************************************************************************************************
              	
8039:         	WORD_Add:									; <<+>>
8039: D9      		exx 
803A: E1      		pop		hl
803B: D1      		pop 	de
803C: 19      		add 	hl,de
803D: E5      		push 	hl
803E: D9      		exx
803F: DDE9    		jp 		(ix)
              	
8041:         	WORD_Subtract: 								; <<->>
8041: D9      		exx 
8042: D1      		pop 	de
8043: E1      		pop 	hl
8044: AF      		xor 	a
8045: ED52    		sbc 	hl,de
8047: E5      		push 	hl
8048: D9      		exx 	
8049: DDE9    		jp 		(ix)
              	
804B:         	WORD_And:									; <<and>>
804B: D9      		exx
804C: D1      		pop 	de
804D: E1      		pop 	hl
804E: 7C      		ld 		a,h 							; do MSB
804F: A2      		and 	d
8050: 67      		ld 		h,a
8051: 7D      		ld 		a,l 							; do LSB
8052: A3      		and 	e
8053:         	__WORD_Logic_Exit:
8053: 6F      		ld 		l,a 							
8054: E5      		push 	hl
8055: D9      		exx
8056: DDE9    		jp 		(ix)
              	
8058:         	WORD_Xor:									; <<xor>>
8058: D9      		exx
8059: D1      		pop 	de
805A: E1      		pop 	hl
805B: 7C      		ld 		a,h 							; do MSB
805C: AA      		xor 	d
805D: 67      		ld 		h,a
805E: 7D      		ld 		a,l 							; do LSB
805F: AB      		xor 	e
8060: 18F1    		jr 		__WORD_Logic_Exit
              	
8062:         	WORD_Or:									; <<or>>
8062: D9      		exx
8063: D1      		pop 	de
8064: E1      		pop 	hl
8065: 7C      		ld 		a,h 							; do MSB
8066: B2      		or 		d
8067: 67      		ld 		h,a
8068: 7D      		ld 		a,l 							; do LSB
8069: B3      		or 		e
806A: 18E7    		jr 		__WORD_Logic_Exit
              	
              		include "library/unary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Unary)
              	;
              	; ****************************************************************************************************
              	
              	; abs sgn
              	
806C:         	WORD_0Minus:								; <<0->>
806C: D9      		exx
806D: D1      		pop 	de
806E: 210000  		ld 		hl,0
8071: AF      		xor 	a
8072: ED52    		sbc 	hl,de
8074: E5      		push 	hl
8075: D9      		exx 	
8076: DDE9    		jp 		(ix)
              	
8078:         	WORD_0Equals:
8078: E1      		pop 	hl 								; <<0=>>
8079: 7C      		ld 		a,h
807A: B5      		or 		l
807B: 2806    		jr 		z,__UNPushTrue
807D:         	__UNPushFalse:
807D: 210000  		ld 		hl,0
8080: E5      		push 	hl
8081: DDE9    		jp 		(ix)
8083:         	__UNPushTrue:
8083: 21FFFF  		ld 		hl,0xFFFF
8086:         	__UNPushHLExit	
8086: E5      		push 	hl
8087: DDE9    		jp		(ix)
              	
8089:         	WORD_0LessThan:								; <<0<>>
8089: E1      		pop 	hl
808A: CB7C    		bit 	7,h
808C: 20F5    		jr 		nz,__UNPushTrue
808E: 18ED    		jr 		__UNPushFalse
              	
8090:         	WORD_Abs:									; <<abs>>
8090: E1      		pop 	hl
8091: CB7C    		bit 	7,h 							
8093: 28F1    		jr 		z,__UNPushHLExit 				; if zero push unchanged
8095: E5      		push 	hl
8096: 18D4    		jr	 	WORD_0Minus 					; otherwise do 0-
              	
8098:         	WORD_Sgn:									; <<sgn>>
8098: E1      		pop 	hl
8099: CB7C    		bit 	7,h 							; -ve
809B: 20E6    		jr 		nz,__UNPushTrue
809D: 7C      		ld 		a,h 							; zero
809E: B5      		or 		l
809F: 28DC    		jr 		z,__UNPushFalse
80A1: 210100  		ld 		hl,1 							; +ve push 1
80A4: 18E0    		jr 		__UNPushHLExit
              		
              	; ****************************************************************************************************
              	;
              	;										Arithmetic Quickies
              	;
              	; ****************************************************************************************************
              	
80A6:         	WORD_OnePlus:
80A6: E1      		pop		hl								; <<1+>>
80A7: 1802    		jr 		__OnePlus
              	
80A9:         	WORD_TwoPlus:
80A9: E1      		pop		hl								; <<2+>>
80AA: 23      		inc 	hl
80AB:         	__OnePlus:	
80AB: 23      		inc 	hl
80AC: E5      		push 	hl
80AD: DDE9    		jp 		(ix)
              	
80AF: E1      		pop		hl								; <<1->>
80B0: 1802    		jr 		__OneMinus
              	
80B2: E1      		pop		hl								; <<1->>
80B3: 2B      		dec 	hl
80B4:         	__OneMinus:	
80B4: 2B      		dec 	hl
80B5: E5      		push 	hl
80B6: DDE9    		jp 		(ix)
              	
80B8: E1      		pop		hl 								; <<2*>>
80B9: 1807    		jr 		__TwoTimes
              	
80BB: E1      		pop 	hl								; <<4*>>
80BC: 1803    		jr 		__FourTimes
              	
80BE: E1      		pop		hl 								; <<16*>>
80BF: 29      		add 	hl,hl
80C0: 29      		add 	hl,hl
80C1:         	__FourTimes:
80C1: 29      		add 	hl,hl
80C2:         	__TwoTimes:	
80C2: 29      		add 	hl,hl
80C3: E5      		push 	hl
80C4: DDE9    		jp 		(ix)
              	
80C6: E1      		pop 	hl 								; <<256*>
80C7: 65      		ld	 	h,l
80C8: 2E00    		ld	 	l,0
80CA: E5      		push 	hl
80CB: DDE9    		jp 		(ix)
              	
80CD: E1      		pop 	hl 								; <<2/>>
80CE: 180D    		jr 		__TwoDivide	
              	
80D0: E1      		pop 	hl 								; <<16/>>
              	
80D1: CB2C    		sra 	h
80D3: CB1D    		rr 		l
80D5: CB2C    		sra 	h
80D7: CB1D    		rr 		l
80D9: CB2C    		sra 	h
80DB: CB1D    		rr 		l
              	
80DD:         	__TwoDivide:
80DD: CB2C    		sra 	h
80DF: CB1D    		rr 		l
80E1: E5      		push 	hl
80E2: DDE9    		jp 		(ix)
              	
80E4: E1      		pop 	hl								; <<256/>>
80E5: 6C      		ld	 	l,h
80E6: 2600    		ld 	 	h,0
80E8: CB7D    		bit 	7,l 							; sign extend
80EA: 2801    		jr 		z,__ByteDivideNotSigned
80EC: 25      		dec 	h
80ED:         	__ByteDivideNotSigned: 	
80ED: E5      		push 	hl
80EE: DDE9    		jp 		(ix)
              		include "library/constants.asm"
              	; ****************************************************************************************************
              	;
              	;						Constants, quicker and shorter versions of .literal
              	;
              	; ****************************************************************************************************
              	
              	ConstantWord macro value
              		ld 		hl,&value 						; <<&value>>
              		push 	hl
              		jp 		(ix)
              		endm
              	;
              	;	If you use these (which the compiler does automatically) it saves two bytes over .literal [n]
              	;	and also is several cycles quicker, because it doesn't fetch the value. A similar system is
              	;	used for variables/arrays/constants as these are all 6 bytes long (same as .literal [n] return)
              	;
              		ConstantWord 	-1
80F0: 21FFFF  		ld 		hl,-1 						; <<-1>>
80F3: E5      		push 	hl
80F4: DDE9    		jp 		(ix)
              		ConstantWord 	0	
80F6: 210000  		ld 		hl,0 						; <<0>>
80F9: E5      		push 	hl
80FA: DDE9    		jp 		(ix)
              		ConstantWord 	1
80FC: 210100  		ld 		hl,1 						; <<1>>
80FF: E5      		push 	hl
8100: DDE9    		jp 		(ix)
              		ConstantWord 	2
8102: 210200  		ld 		hl,2 						; <<2>>
8105: E5      		push 	hl
8106: DDE9    		jp 		(ix)
              		ConstantWord 	4
8108: 210400  		ld 		hl,4 						; <<4>>
810B: E5      		push 	hl
810C: DDE9    		jp 		(ix)
              		ConstantWord 	8
810E: 210800  		ld 		hl,8 						; <<8>>
8111: E5      		push 	hl
8112: DDE9    		jp 		(ix)
              		ConstantWord 	10
8114: 210A00  		ld 		hl,10 						; <<10>>
8117: E5      		push 	hl
8118: DDE9    		jp 		(ix)
              		ConstantWord 	16
811A: 211000  		ld 		hl,16 						; <<16>>
811D: E5      		push 	hl
811E: DDE9    		jp 		(ix)
              		ConstantWord 	100
8120: 216400  		ld 		hl,100 						; <<100>>
8123: E5      		push 	hl
8124: DDE9    		jp 		(ix)
              		ConstantWord 	256
8126: 210001  		ld 		hl,256 						; <<256>>
8129: E5      		push 	hl
812A: DDE9    		jp 		(ix)
              	
              		include "library/stack.asm"
              	; ****************************************************************************************************
              	;
              	;										  Stack Manipulation
              	;
              	; ****************************************************************************************************
              	
812C:         	WORD_Dup:									; <<dup>>
812C: E1      		pop 	hl 								; get TOS and push it back twice
812D: E5      		push 	hl
812E: E5      		push 	hl
812F: DDE9    		jp 		(ix) 							; return 
              	
8131:         	WORD_Drop:									; <<drop>>
8131: E1      		pop 	hl
8132: DDE9    		jp 		(ix)
              	
8134:         	WORD_Swap:									; <<swap>>
8134: D9      		exx 									; use alt register set
8135: E1      		pop 	hl 								; get TOS and push it back twice
8136: D1      		pop 	de
8137: E5      		push 	hl
8138: D5      		push 	de
8139: D9      		exx 
813A: DDE9    		jp 		(ix) 							; return 
              	
813C:         	WORD_Over:									; <<over>>
813C: D9      		exx 						
813D: E1      		pop 	hl 								; tos
813E: D1      		pop 	de 								; tos 2
813F: D5      		push 	de 								; push back
8140: E5      		push 	hl
8141: D5      		push 	de 								; with tos 2 on top
8142: D9      		exx
8143: DDE9    		jp 		(ix)
              	
8145:         	WORD_Rot:									; <<rot>>
8145: D9      		exx
8146: E1      		pop 	hl 								; X3  X1 X2 X3 -> X2 X3 X1
8147: D1      		pop 	de 								; X2 
8148: C1      		pop		bc 								; X1
8149: D5      		push 	de
814A: E5      		push 	hl
814B: C5      		push 	bc
814C: D9      		exx
814D: DDE9    		jp 		(ix)
              	
814F:         	WORD_Pick:									; <<pick>>
814F: D9      		exx 		
8150: E1      		pop 	hl 								; get the index off the stack
8151: 39      		add 	hl,sp 							; add stack offset
8152: 56      		ld 		d,(hl) 							; read stack value
8153: 23      		inc 	hl
8154: 5E      		ld 		e,(hl)
8155: D5      		push 	de 								; push on the stack
8156: D9      		exx
8157: DDE9    		jp 		(ix)
              		include "library/misc.asm"
              	; ****************************************************************************************************
              	;
              	; 												Miscellany
              	;
              	; ****************************************************************************************************
              	
              	
8159:         	WORD_Branch:								; <<[br]>>
8159: EB      		ex 	 	de,hl 							; HL now points to the next word
815A: 5E      		ld 		e,(hl)							; read into DE
815B: 23      		inc 	hl
815C: 56      		ld 		d,(hl)
815D: DDE9    		jp 		(ix) 							; and go there.
              	
815F:         	WORD_BranchZero:
815F: E1      		pop 	hl 								; non destructive test of TOS
8160: E5      		push 	hl
8161: 7C      		ld 		a,h 							; branch if zero.
8162: B5      		or 		l
8163: 28F4    		jr 		z,WORD_Branch
8165:         	__WORD_BranchFail:							; if non zero
8165: 13      		inc 	de 								; skip over jump address
8166: 13      		inc 	de
8167: DDE9    		jp 		(ix)
              	
8169:         	WORD_BranchPositive:
8169: E1      		pop 	hl 								; non destructive test of TOS
816A: E5      		push 	hl
816B: CB7C    		bit 	7,h 							; if +ve branch
816D: 28EA    		jr 		z,WORD_Branch
816F: 18F4    		jr 		__WORD_BranchFail 				; if -ve don't
              	
8171:         	WORD_Stop:									; <<stop>>
8171: 18FE    		jr 		WORD_Stop
              	
8173:         	WORD_RStoDS:								; <<r>>>
8173: 0A      		ld 		a,(bc) 							; pop address into HL
8174: 0B      		dec 	bc
8175: 67      		ld 		h,a 
8176: 0A      		ld 		a,(bc)
8177: 0B      		dec 	bc
8178: 6F      		ld 		l,a
8179: E5      		push 	hl 								; push on data stack.
817A: DDE9    		jp 		(ix)
              	
817C:         	WORD_DStoRS:								; <<>r>>
817C: E1      		pop 	hl 								; get top of data stack
817D: 03      		inc 	bc 								; push on return stack.
817E: 7D      		ld 		a,l
817F: 02      		ld 		(bc),a
8180: 03      		inc 	bc
8181: 7C      		ld 		a,h
8182: 02      		ld 		(bc),a
8183: DDE9    		jp 		(ix)
              	
8185:         	WORD_RDrop:									; <<rdrop>>
8185: 0B      		dec 	bc
8186: 0B      		dec 	bc
8187: DDE9    		jp 		(ix)
              		include "library/io.asm"
              	; ****************************************************************************************************
              	;
              	;										Input/Output functions
              	;
              	; ****************************************************************************************************
              	
8189:         	WORD_Emit:									; <<emit>>
8189: E1      		pop 	hl 								; get character to print in L
818A: CDCD81  		call	PrintCharL
818D: DDE9    		jp 		(ix)
              	
818F:         	WORD_PrintInteger:							; <<.>>
818F: E1      		pop 	hl
8190: CD2B82  		call 	PrintInteger
8193: DDE9    		jp 		(ix)
              	
8195:         	WORD_PrintStack:							; <<.stack>>
8195: D5      		push 	de 								; save DE
8196: 210000  		ld 		hl,0  							; get SP into HL
8199: 23      		inc 	hl 								; skip over PUSH DE above
819A: 23      		inc 	hl
819B: 39      		add 	hl,sp
819C: 3E46    		ld  	a,46h 							; first yellow
819E: 328282  		ld 		(__PCAColour),a
81A1:         	__PSLoop:
81A1: 5E      		ld 		e,(hl) 							; load into DE
81A2: 23      		inc 	hl
81A3: 56      		ld 		d,(hl)
81A4: 23      		inc 	hl
81A5: EB      		ex 		de,hl 							; print it
81A6: CD2B82  		call 	PrintInteger
81A9: EB      		ex 		de,hl
81AA: 3E44    		ld  	a,44h 							; remainder green
81AC: 328282  		ld 		(__PCAColour),a
81AF: 7C      		ld 		a,h 							; reached top of stack
81B0: B7      		or 		a
81B1: 20EE    		jr 		nz,__PSLoop
81B3: D1      		pop 	de 								; restore DE
81B4: 2E0D    		ld 		l,13 							; print CR
81B6: CDCD81  		call 	PrintCharL
81B9: DDE9    		jp 		(ix)
              	
81BB:         	WORD_ClearScreen:							; <<cls>>
81BB: CD5282  		call 	ClearScreen
81BE: CD6E82  		call 	HomeCursor
81C1: DDE9    		jp 		(ix)
              	
81C3:         	WORD_CR:									; <<cr>>
81C3: FDE9    		jp 		(iy)
81C5: 2980    		defw 	Core_Literal
81C7: 0D00    		defw 	13
81C9: 8981    		defw 	WORD_Emit
81CB: 3180    		defw 	Core_Return
              	
              	; ****************************************************************************************************
              	;			This is included if io.asm is included, provides direct I/O to Speccy hardware
              	; ****************************************************************************************************
              	
              		include "utils/screen.asm" 				; Screen I/O routines.
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;			Replacement for Spectrums Screen Display Routine, straight 32x24 video display
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;							Print character in L ; all registers preserved.
              	;
              	; ****************************************************************************************************
              	
81CD:         	PrintCharL:
81CD: F5      		push 	af 								; stack registers
81CE: C5      		push 	bc 								
81CF: D5      		push 	de
81D0: E5      		push 	hl
              	
81D1: 7D      		ld 		a,l 							; check for CR ?
81D2: FE0D    		cp 		13
81D4: 2847    		jr		z,__PCLReturn
              	
81D6: 0600    		ld 		b,0 							; B is the reversing byte
81D8: CB7D    		bit 	7,l 							; if bit 7 set
81DA: 2803    		jr 		z,__PCANotReverse
81DC: 05      		dec 	b 								; B becomes $FF
81DD: CBBD    		res 	7,l 							; drop bit 7
81DF:         	__PCANotReverse:
81DF: 2600    		ld 		h,0 							; HL to 16 bit
81E1: ED5B7C82		ld 		de,(__PCAFont)					; DE = Font Base
81E5: 29      		add 	hl,hl 							; calc Font Base + char * 8
81E6: 29      		add 	hl,hl
81E7: 29      		add 	hl,hl
81E8: 19      		add 	hl,de
81E9: EB      		ex 		de,hl 							; put in DE
81EA: 2A7E82  		ld 		hl,(__PCAVideoPos) 				; get write address
81ED: E5      		push 	hl 								; save for later
81EE:         	_PCALoop:	
81EE: 1A      		ld 		a,(de) 							; read font char
81EF: A8      		xor 	b 								; reverse byte
81F0: 77      		ld 		(hl),a 							; write to screen
81F1: 1C      		inc 	e 								; bump pointers
81F2: 24      		inc 	h
81F3: 7C      		ld 		a,h 							; until done whole row
81F4: E607    		and 	7
81F6: 20F6    		jr 		nz,_PCALoop
              	
              	
81F8: ED5B8082		ld 		de,(__PCAAttribPos)				; copy colour byte to attribute memory.
81FC: 3A8282  		ld 		a,(__PCAColour)
81FF: 12      		ld 		(de),a
8200: 13      		inc 	de
              	
8201: E1      		pop 	hl 								; restore original video position to HL
8202: 2C      		inc 	l 								; right one
8203: 200C    		jr 		nz,__PCANotNewPage 				; if nz don't need new 1/4k page
8205: 7C      		ld 		a,h 							; advance to next quarter page
8206: C608    		add 	8
8208: 67      		ld 		h,a 	
8209: FE58    		cp 		0x58 							; we only have 3, this is the attribute page
820B: 2004    		jr 		nz,__PCANotNewPage
820D: 2640    		ld 		h,0x40 							; wrap round to top.
820F: 1658    		ld 		d,0x58 							; reset attribute memory pointer
8211:         	__PCANotNewPage:
8211: 227E82  		ld 		(__PCAVideoPos),hl 				; update new position in video / attr
8214: ED538082		ld 		(__PCAAttribPos),de 			
              	
8218:         	__PCLExit:
8218: E1      		pop 	hl 								; destack.
8219: D1      		pop 	de
821A: C1      		pop 	bc
821B: F1      		pop 	af
821C: C9      		ret
              	
821D:         	__PCLReturn: 								; carriage return.
821D: 2E20    		ld 		l,' '
821F: CDCD81  		call 	PrintCharL
8222: 3A7E82  		ld 		a,(__PCAVideoPos)
8225: E61F    		and 	31
8227: 20F4    		jr 		nz,__PCLReturn
8229: 18ED    		jr 		__PCLExit
              	
              	; ****************************************************************************************************
              	;
              	;									Print HL in hexadecimal
              	;
              	; ****************************************************************************************************
              	
822B:         	PrintInteger:
822B: E5      		push 	hl
822C: 2E20    		ld 		l,' ' 							; print leading space
822E: CDCD81  		call 	PrintCharL
8231: E1      		pop 	hl
8232: 7C      		ld 		a,h
8233: CD3B82  		call 	PrintByteA
8236: 7D      		ld 		a,l
8237: CD3B82  		call 	PrintByteA
823A: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;									Print Byte in Hexadecimal
              	;
              	; ****************************************************************************************************
              	
823B:         	PrintByteA:
823B: F5      		push 	af 								; save A on stack
823C: 1F      		rra 									; shift right 4
823D: 1F      		rra
823E: 1F      		rra
823F: 1F      		rra
8240: CD4482  		call	__PBANibble 					; print it
8243: F1      		pop 	af 								; restore
8244:         	__PBANibble:
8244: F6F0    		or 		0F0h 							; DAA trick
8246: 27      		daa
8247: C6A0    		add 	a,0A0h
8249: CE40    		adc 	a,040h
824B: E5      		push 	hl 								; print character
824C: 6F      		ld 		l,a
824D: CDCD81  		call 	PrintCharL
8250: E1      		pop 	hl
8251: C9      		ret
              	
              	; ****************************************************************************************************
              	;	
              	;											Clear Screen
              	;
              	; ****************************************************************************************************
              	
8252:         	ClearScreen:
8252: E5      		push 	hl
8253: 210040  		ld 		hl,0x4000 						; fill 4000-57FF with zero
8256:         	__CLSLoop1:
8256: 3600    		ld 		(hl),0
              	
8258: 3642    		ld 		(hl),042h
              	
825A: 23      		inc 	hl
825B: 7C      		ld 		a,h
825C: FE58    		cp 		0x58
825E: 20F6    		jr		nz,__CLSLoop1
8260:         	__CLSLoop2:									; fill 5800-5FFF with 7 (white)
8260: 3607    		ld 		(hl),7
8262: 23      		inc 	hl
8263: 7C      		ld 		a,h
8264: FE60    		cp 		0x60
8266: 20F8    		jr		nz,__CLSLoop2
8268: 3E01    		ld 		a,1 							; set border to blue.
826A: D3FE    		out 	(0xFE),a
826C: E1      		pop 	hl
826D: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Home Cursor
              	;
              	; ****************************************************************************************************
              	
826E:         	HomeCursor:	
826E: E5      		push 	hl
826F: 210058  		ld 		hl,0x5800 						; reset attribute pos
8272: 228082  		ld 		(__PCAAttribPos),hl
8275: 2640    		ld 		h,0x40 							; reset video pos
8277: 227E82  		ld 		(__PCAVideoPos),hl
827A: E1      		pop 	hl
827B: C9      		ret
              	
827C:         	__PCAFont: 									; font base here
827C: 003C    		defw 	0x3C00
827E:         	__PCAVideoPos: 								; current video memory pointer.
827E: 0040    		defw 	VideoMemory
8280:         	__PCAAttribPos:								; current attribute pointer
8280: 0058    		defw 	AttributeMemory
8282:         	__PCAColour: 								; current colour to use
8282: 44      		defb 	0x44
              		include "library/utils/sprites.asm"
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;										16 x n Sprite Routines
              	;
              	;	Sprites can be either simple XOR, Masked AND/XOR or they can preserve their background data.
              	;
              	;	There is some self modifying code here - the pointers are all kept in SMC, so is the counter
              	;	and it is also used to modify the 24 bit shifter.
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	;
              	;	+0 			X position
              	;	+1 			Y position
              	;	+2 			Vertical Size (bits 0..6)
              	;	+3 			Drawing color (0 = don't do attribute)
              	;	+4,5 		pointer to 16 bit pixel data 
              	;	+6,7 		either 0 (not back stored) or pointer to background storage (pointer + 3 x vertical size)
              	;	+8,9 		either 0 (no mask data) or pointer to mask data, note set to clear background.
              	;
              	
8283:         	DrawSprite:
8283: DD218383		ld 		ix,testSprite
              	
              	;
              	;	Set up  screen position
              	;
              	
              	; ****************************************************************************************************
              	;						Copy structure details into the self modifying code
              	; ****************************************************************************************************
              	
8287: DD7E02  		ld 			a,(ix+2)					; vertical size
828A: E67F    		and 		7Fh
828C: 322D83  		ld 			(__DSLoadVerticalCount+1),a
              	
828F: DD6E04  		ld 			l,(ix+4)					; graphic data
8292: DD6605  		ld 			h,(ix+5)
8295: 220383  		ld 			(__DSLoadGraphicData+1),hl
              	
8298: DD6E06  		ld 			l,(ix+6)					; background store
829B: DD6607  		ld 			h,(ix+7)
829E: 22CB82  		ld 			(__DSLoadStoreAddress+1),hl
              	
82A1: DD6E08  		ld 			l,(ix+8)					; mask data
82A4: DD6609  		ld 			h,(ix+9)
82A7: 22DF82  		ld 			(__DSLoadMaskAddress+1),hl
              	
              	; ****************************************************************************************************
              	;					Set up the pixel shifter for the 3 LSB of the x coordinate
              	; ****************************************************************************************************
              	
82AA: DD7E00  		ld 		a,(ix+0) 						; x 0-7 pixels
82AD: E607    		and 	7
82AF: 2804    		jr 		z,__DSOffsetDone 				; if zero, the JR will just fall through to register move
82B1: 3D      		dec 	a
82B2: 87      		add 	a,a	
82B3: C605    		add 	__DSShiftEntry-__DSShiftAHL-2
82B5:         	__DSOffsetDone:
82B5: 326E83  		ld 		(__DSShiftAHL+1),a 				; set the JR offset.
              	
              	; ****************************************************************************************************
              	;								Copy the starting screen position
              	; ****************************************************************************************************
              	
82B8: 2ACB82  		ld 		hl,(__DSLoadStoreAddress+1) 	; get where we are copying old screen data to
82BB: 7C      		ld 		a,h
82BC: B5      		or 		l
82BD: 280B    		jr 		z,__DSMainLoop
82BF: ED5BF382		ld 		de,(__DSLoadScreenAddress+1)	; this is where we copy stuff to on the screen
82C3: 73      		ld 		(hl),e 							; copy that address into the first 2 bytes of store address
82C4: 23      		inc 	hl
82C5: 72      		ld 		(hl),d
82C6: 23      		inc 	hl
82C7: 22CB82  		ld 		(__DSLoadStoreAddress+1),hl 	; write it back
              	
              	; ****************************************************************************************************
              	;   						   S P R I T E     M A I N     L O O P
              	; ****************************************************************************************************
              	
82CA:         	__DSMainLoop:
              	
              	; ****************************************************************************************************
              	;						Copy current screen address to storage if it exists
              	; ****************************************************************************************************
              	
82CA:         	__DSLoadStoreAddress:
82CA: 110000  		ld 		de,0 							; look at back storage
82CD: 7A      		ld 		a,d 							; if zero, then we don't copy out.
82CE: B3      		or 		e
82CF: 280D    		jr 		z,__DSMaskGraphicOutline
82D1: 2AF382  		ld 		hl,(__DSLoadScreenAddress+1) 	; HL = source DE = target
82D4: EDA0    		ldi 									; copy three bytes. 
82D6: EDA0    		ldi
82D8: EDA0    		ldi
82DA: ED53CB82		ld 		(__DSLoadStoreAddress+1),de 	; save the new target address, 3 bytes on.
              	
              	; ****************************************************************************************************
              	;						Mask the graphic mask onto the screen, if it is in use
              	; ****************************************************************************************************
              	
82DE:         	__DSMaskGraphicOutline:
              	
82DE:         	__DSLoadMaskAddress:
82DE: 210000  		ld 		hl,0 							; mask data address
82E1: 7C      		ld 		a,h
82E2: B5      		or 		l 								; if mask address is zero, then don't do the mask.
82E3: 281D    		jr 		z,__DSXorGraphic
              	
82E5: 56      		ld 		d,(hl) 							; read mask into DE
82E6: 23      		inc 	hl
82E7: 5E      		ld 		e,(hl)
82E8: 23      		inc 	hl
82E9: 22DF82  		ld 		(__DSLoadMaskAddress+1),hl 		; update the mask data address
              	
82EC: EB      		ex 		de,hl 							; 16 bit now in HL.
82ED: AF      		xor  	a 								; 24 bit graphic in AHL
82EE: CD6D83  		call 	__DSShiftAHL					; shift it accordingly
82F1: EB      		ex 		de,hl 							; now it is in ADE
              	
82F2:         	__DSLoadScreenAddress:
82F2: 21124A  		ld 		hl,4A12h						; where we will write on the screen
              	
82F5: 2F      		cpl 									; mask the ADE bytes - 1's complement each and AND into screen
82F6: A6      		and		(hl)
82F7: 77      		ld 		(hl),a
82F8: 2C      		inc 	l
82F9: 7A      		ld 		a,d
82FA: 2F      		cpl
82FB: A6      		and		(hl)
82FC: 77      		ld 		(hl),a
82FD: 2C      		inc 	l
82FE: 7B      		ld 		a,e
82FF: 2F      		cpl
8300: A6      		and 	(hl)
8301: 77      		ld 		(hl),a
              	
              	
              	; ****************************************************************************************************
              	;								XOR the graphic data into the screen
              	; ****************************************************************************************************
8302:         	__DSXorGraphic:
              	
8302:         	__DSLoadGraphicData:
8302: 210000  		ld 		hl,0 							; pointer to graphic data (modified in-line)
8305: 56      		ld 		d,(hl) 							; read into DE
8306: 23      		inc 	hl
8307: 5E      		ld 		e,(hl)
8308: 23      		inc 	hl
8309: 220383  		ld 		(__DSLoadGraphicData+1),hl 		; update graphic data pointer
              	
830C: EB      		ex 		de,hl 							; 16 bit now in HL.
830D: AF      		xor  	a 								; 24 bit graphic in AHL
              	
830E: CD6D83  		call 	__DSShiftAHL					; shift it accordingly
              	
8311: EB      		ex 		de,hl 							; now it is in ADE
8312: 2AF382  		ld 		hl,(__DSLoadScreenAddress+1) 	; HL is where it is XORed into.
              	
8315: AE      		xor 	(hl) 							; XOR those three bytes in to the screen
8316: 77      		ld 		(hl),a
8317: 2C      		inc 	l
8318: 7A      		ld 		a,d
8319: AE      		xor 	(hl)
831A: 77      		ld 		(hl),a
831B: 2C      		inc 	l
831C: 7B      		ld 		a,e
831D: AE      		xor 	(hl)
831E: 77      		ld 		(hl),a
831F: 2D      		dec 	l 								; unpick the increment so HL points to the first byte
8320: 2D      		dec 	l
              	
              	; ****************************************************************************************************
              	;										Move to the next line down
              	; ****************************************************************************************************
              	
8321: CD3583  		call 	__DSHLDown 						; HL Down one line
8324: 7C      		ld 		a,h
8325: FE58    		cp 		58h								; into attribute memory ?
8327: 280B    		jr 		z,__DSExitEarly 				; off bottom of screen, end of sprite draw
              	
8329:         	__DSNoOverflowScreen1
8329: 22F382  		ld 		(__DSLoadScreenAddress+1),hl 	; update the screen address.
              	
832C:         	__DSLoadVerticalCount:
832C: 3E0A    		ld 		a,10 							; count of lines to do
832E: 3D      		dec 	a 								; decrement and update
832F: 322D83  		ld 		(__DSLoadVerticalCount+1),a 	
8332: 2096    		jr 		nz,__DSMainLoop 				; keep going till done all lines, or reached the end of screen memory
8334:         	__DSExitEarly:
              	
              	;	call 	__DSRestoreSavedScreen
8334: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;		Advance the line address HL down by 1, handles the slightly odd screen arrangement
              	;
              	; ****************************************************************************************************
              	
8335:         	__DSHLDown:
8335: 24      		inc 	h 								; next line down.
8336: 7C      		ld 		a,h 							; have we stepped over the border
8337: E607    		and 	7
8339: C0      		ret 	nz
              	
833A: 7C      		ld 		a,h 							; fix up three lower bits of high address byte
833B: D608    		sub 	8
833D: 67      		ld 		h,a
              	
833E: 7D      		ld 		a,l 							; next block of 8 down, high 3 bits of low address byte
833F: C620    		add 	32
8341: 6F      		ld 		l,a
8342: D0      		ret		nc
              	
8343: 7C      		ld 		a,h 							; next page down.
8344: C608    		add 	8
8346: 67      		ld 		h,a
8347: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;						Repair damage - restore saved screen for sprite at IX
              	;
              	; ****************************************************************************************************
              	
8348:         	__DSRestoreSavedScreen:
8348: DD4602  		ld 		b,(ix+2)						; set counter
834B: CBB8    		res 	7,b
834D: DD6E06  		ld 		l,(ix+6)						; get address of data
8350: DD6607  		ld 		h,(ix+7)
8353: 7C      		ld 		a,h 							; return if zero (e.g. no storage)
8354: B5      		or 		l
8355: C8      		ret 	z
8356: 5E      		ld 		e,(hl)							; read start address of screen into DE
8357: 23      		inc 	hl
8358: 56      		ld 		d,(hl)
8359: 23      		inc 	hl
              	
835A:         	__DSRLoop:
835A: C5      		push 	bc
835B: EDA0    		ldi  									; copy three bytes (HL) to (DE)	
835D: EDA0    		ldi 
835F: EDA0    		ldi 
8361: 1B      		dec 	de 								; fix up DE 								
8362: 1B      		dec 	de
8363: 1B      		dec 	de
8364: EB      		ex 		de,hl 							; HL = screen
8365: CD3583  		call	__DSHLDown	 					; down one line
8368: EB      		ex 		de,hl 							; put back so DE screen HL data
              	
8369: C1      		pop		bc 								; do once for each line
836A: 10EE    		djnz 	__DSRLoop
836C: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;	Shift the 24 bit value AHL left a number of times defined by the x coordinate, set up at the
              	;	start of the drawing routine.
              	;
              	; ****************************************************************************************************
              	
836D:         	__DSShiftAHL:
836D: 1805    		jr 		__DSShiftEntry 					; this jump vector is zero if x % 8 = 0, otherwise it jumps into code below to shift
836F: 7C      		ld 		a,h
8370: 65      		ld 		h,l
8371: 2E00    		ld 		l,0
8373: C9      		ret
              	
8374:         	__DSShiftEntry:
8374: 29      		add 	hl,hl 							; the JR at __DSShiftEntry jumps into this code.
8375: 8F      		adc 	a,a
8376: 29      		add 	hl,hl
8377: 8F      		adc 	a,a
8378: 29      		add 	hl,hl
8379: 8F      		adc 	a,a
837A: 29      		add 	hl,hl
837B: 8F      		adc 	a,a
              	
837C: 29      		add 	hl,hl
837D: 8F      		adc 	a,a
837E: 29      		add 	hl,hl
837F: 8F      		adc 	a,a
8380: 29      		add 	hl,hl
8381: 8F      		adc 	a,a
8382: C9      		ret
              	
8383:         	testSprite:
8383: 07      		defb 	7
8384: 04      		defb 	4
8385: 0A      		defb 	10
8386: 00      		defb 	0
8387: A583    		defw 	graphicData
8389: 8D83    		defw 	backStore
838B: B983    		defw 	maskData
              	
838D:         	backStore:
838D: 00000000		defs 	8*3
8391: 00...   	
              	
83A5:         	graphicData:
83A5: FFFF    		defb 	0FFh,0FFh
83A7: AAAA    		defb 	0AAh,0AAh
83A9: 8003    		defb 	080h,003h
83AB: 8007    		defb 	080h,007h
83AD: 8F0F    		defb 	08Fh,00Fh
83AF: 801F    		defb 	080h,01Fh
83B1: FFE0    		defb 	0FFh,0E0h
83B3: 0200    		defb 	002h,000h
83B5: 0200    		defb 	002h,000h
83B7: 0700    		defb 	007h,000h
              	
83B9:         	maskData:
83B9: FFFF    		defb 	0FFh,0FFh
83BB: FFFF    		defb 	0FFh,0FFh
83BD: FFFF    		defb 	0FFh,0FFh
83BF: FFFF    		defb 	0FFh,0FFh
83C1: FFFF    		defb 	0FFh,0FFh
83C3: FFFF    		defb 	0FFh,0FFh
83C5: FFFF    		defb 	0FFh,0FFh
83C7: FFFF    		defb 	0FFh,0FFh
83C9: FFFF    		defb 	0FFh,0FFh
              	
              	
83CB:         	BootWord:
83CB: FDE9    		jp 			(iy)
83CD: BB81    		defw 		WORD_ClearScreen
83CF: E483    		defw 		WORD_Star
83D1: D783    		defw 		Test
83D3: E483    		defw 		WORD_Star
83D5: 7181    		defw 		WORD_Stop
              	
83D7:         	Test:
83D7: C5      		push 		bc
83D8: D5      		push 		de
83D9: DDE5    		push 		ix
83DB: CD8382  		call 		DrawSprite
83DE: DDE1    		pop 		ix
83E0: D1      		pop 		de
83E1: C1      		pop			bc
83E2: DDE9    		jp 			(ix)
              	
83E4:         	WORD_Star:
83E4: FDE9    		jp 			(iy)
83E6: 2980    		defw 		Core_Literal
83E8: 2A00    		defw 		42
83EA: 8981    		defw 		WORD_Emit
83EC: 3180    		defw 		Core_Return
              	
83EE:         	EndOfCode:
              	
              	; ****************************************************************************************************
              	;
              	;												Examples
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	Code word (example) DUP. Note that in code words DE is the code pointer.
              	;	We just go straight in with the machine code. Code words can only use HL as a temporary value
              	; 	so for things like + use EXX and do it in the alternate set.
              	;
              	;
              	;dup:										; <<dup>>
              	;	pop 	hl
              	;	push 	hl
              	;	push 	hl
              	;	jp		(ix)							; and fix up so HL is the code pointer again and loop
              	;
              	;
              	;
              	;	Word built up out of other definitions.
              	;	
              	;	jp 		(iy)							; identifies as a word from words.
              	;
              	;	; first def addr
              	;	; second def addr
              	;	;	..
              	;	;	..
              	;
              	;	defw 	Core_Return 					; now we want to go back.
              	;
              	
              	
              	


total time: 0.0021 sec.
no errors
