              	; --------------------------------------
              	; zasm: assemble "forth.asm"
              	; date: 2017-05-15 09:48:21
              	; --------------------------------------


              	; ****************************************************************************************************
              	;
              	;									Forth Compiler Runtime
              	;
              	; ****************************************************************************************************
              	
              		include 	"sna_header.asm"			; .SNA boot header
              	; *****************************************************************************************
              	; *****************************************************************************************
              	;
              	;                       SNA Header - variant of the provided example.
              	;
              	; *****************************************************************************************
              	; *****************************************************************************************
              	
              	#target sna
              	
              	; *****************************************************************************************
              	;
              	;                               saved registers, restored in NMI
              	;
              	; *****************************************************************************************
              	
0000:         	#code HEAD, 0, 27
0000: 3F      	    defb    $3f             ; i
0001: 0000    	    defw    0               ; hl'
0003: 0000    	    defw    0               ; de'
0005: 0000    	    defw    0               ; bc'
0007: 0000    	    defw    0               ; af'
              	
0009: 0000    	    defw    0               ; hl
000B: 0000    	    defw    0               ; de
000D: 0000    	    defw    0               ; bc
000F: 0000    	    defw    0               ; iy
0011: 0000    	    defw    0               ; ix
              	
0013: 00      	    defb    0<<2            ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei
0014: 000000  	    defb    0,0,0           ; r,f,a
0017: 035B    	    defw    __stackEnd      ; sp
0019: 01      	    defb    1               ; irpt mode
001A: 00      	    defb    0               ; border color: 0=black ... 7=white
              	
              	; *****************************************************************************************
              	;
              	;                   $4000-$7FFF. Pixel Memory, Attribute Memory, Slow RAM
              	;
              	; *****************************************************************************************
              	
4000:         	#code SLOW_RAM, 0x4000, 0x4000
              	
4000:         	VideoMemory:
4000: 00000000	    defs    0x1800
4004: 00...   	
5800:         	AttributeMemory:
5800: 00000000	    defs    0x300
5804: 00...   	
5B00:         	EndVideoMemory:
              	
5B00:         	__bootSNA:
5B00: C30480  	    jp      start
              	
              	; *****************************************************************************************
              	;
              	;                            $8000-$FFFF. Non contentious memory
              	;
              	; *****************************************************************************************
              	
5B03:         	__stackEnd:   
5B03: 005B    	    defw    __bootSNA
              	
8000:         	#code FAST_RAM, 0x8000, 0x8000
              	
              		include 	"core4.asm" 				; Forth core (Direct Threaded)
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;													Core v4
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;	These words are accessed/changed by the compiler, so it knows (i) where to start the program
              	;	and (ii) where it can compile code.
              	;
              	; ****************************************************************************************************
              	
8000:         	BootAddress:
8000: 3F82    		defw 	BootWord 						; start of threaded word.
8002:         	FreeAddress:
8002: 6D82    		defw 	EndOfCode 						; end of code that is built with the assembler.
              	
              	; ****************************************************************************************************
              	;
              	;										Start Forth Core
              	;
              	; ****************************************************************************************************
              		
8004:         	start:
8004: DD212280		ld 		ix,Core_Continue  				; these allow us to do fast jumps in and out of routines.
8008: FD211980		ld 		iy,Core_Call 					; also saving a byte on long jumps.
              	
800C: 310000  		ld 		sp,0x0000 						; sp is the data stack (works down)
800F: 0100FF  		ld 		bc,0xFF00 						; bc is the return stack (works up)
              	
8012: 2A0080  		ld 		hl,(BootAddress)				; hl is the IP (except when executing Z80 code words)
8015: 23      		inc 	hl 								; skip over the JP (IY)
8016: 23      		inc 	hl
8017: 180A    		jr 		Core_Execute
              	
              	; ****************************************************************************************************
              	;
              	;		The JP (IY) at the start of a threaded definition comes here. DE contains
              	; 		the old address, HL the new one.
              	;
              	;		Save the calling address on the stack and execute from HL. Which handily is in HL.
              	;
              	; ****************************************************************************************************
              	
8019:         	Core_Call:
8019: 23      		inc 	hl 								; advance HL over the JP(IY) $FD $E9
801A: 23      		inc 	hl 								; now points to the first definition
              	
801B: 7B      		ld 		a,e 							; push DE (old address) on the BC stack.
801C: 03      		inc 	bc 								; unfortunately a Z80 only has one stack, so we have
801D: 02      		ld 		(bc),a 							; to use it for either data *or* return.
801E: 7A      		ld 		a,d
801F: 03      		inc 	bc
8020: 02      		ld 		(bc),a
              	
8021: EB      		ex 		de,hl 							; allows us to fall through to execute loop
              	
              	; ****************************************************************************************************
              	;
              	;	Ending a machine code definition comes here (using JP (IX)). We need this exchange
              	; 	because when running m/c definition DE is the instruction pointer
              	;
              	; ****************************************************************************************************
              	
8022:         	Core_Continue:
8022: EB      		ex 		de,hl 							; if executing code word come back here.
              	
              	; ****************************************************************************************************
              	;
              	;					Main execution entry point. Execute instruction at (DE)
              	;
              	; ****************************************************************************************************
              	
8023:         	Core_Execute:
8023: 5E      		ld 		e,(hl)							; read address of next word at HL into DE, LSB first
8024: 23      		inc 	hl
8025: 56      		ld 		d,(hl)
8026: 23      		inc 	hl
8027: EB      		ex 		de,hl 							; swap so when executing code word DE code ptr and so we can 
8028: E9      		jp 		(hl) 							; do this 4 cycle jump
              	
              	; ****************************************************************************************************
              	;
              	;											16 bit literal word
              	;
              	; ****************************************************************************************************
              	
8029:         	Core_Literal:								; <<.literal>>
8029: EB      		ex 		de,hl 							; HL now contains the IP back again.
802A: 5E      		ld 		e,(hl) 							; load next word into DE
802B: 23      		inc 	hl
802C: 56      		ld 		d,(hl)
802D: 23      		inc 	hl
802E: D5      		push 	de 								; push word on data stack
802F: 18F2    		jr 		Core_Execute 					; and execute without doing the DE/HL swap
              	
              	; ****************************************************************************************************
              	;
              	;												Return word.
              	;
              	; ****************************************************************************************************
              	
8031:         	Core_Return:								; <<;>>
8031: 0A      		ld 		a,(bc) 							; pop address into DE.
8032: 0B      		dec 	bc
8033: 57      		ld 		d,a 
8034: 0A      		ld 		a,(bc)
8035: 0B      		dec 	bc
8036: 5F      		ld 		e,a
8037: DDE9    		jp 		(ix) 							; this will put DE -> HL and start executing one level up.
              	
              		include 	"library.asm" 				; Basic FORTH words
              	; ****************************************************************************************************
              	;
              	;								 Basic FORTH Library, Z80 Assembler
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	over rot pick
              	;	br bz bpl r> >r rdrop
              	;
              		include "library/binary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Binary)
              	;
              	; ****************************************************************************************************
              	
8039:         	WORD_Add:									; <<+>>
8039: D9      		exx 
803A: E1      		pop		hl
803B: D1      		pop 	de
803C: 19      		add 	hl,de
803D: E5      		push 	hl
803E: D9      		exx
803F: DDE9    		jp 		(ix)
              	
8041:         	WORD_Subtract: 								; <<->>
8041: D9      		exx 
8042: D1      		pop 	de
8043: E1      		pop 	hl
8044: AF      		xor 	a
8045: ED52    		sbc 	hl,de
8047: E5      		push 	hl
8048: D9      		exx 	
8049: DDE9    		jp 		(ix)
              	
804B:         	WORD_And:									; <<and>>
804B: D9      		exx
804C: D1      		pop 	de
804D: E1      		pop 	hl
804E: 7C      		ld 		a,h 							; do MSB
804F: A2      		and 	d
8050: 67      		ld 		h,a
8051: 7D      		ld 		a,l 							; do LSB
8052: A3      		and 	e
8053:         	__WORD_Logic_Exit:
8053: 6F      		ld 		l,a 							
8054: E5      		push 	hl
8055: D9      		exx
8056: DDE9    		jp 		(ix)
              	
8058:         	WORD_Xor:									; <<xor>>
8058: D9      		exx
8059: D1      		pop 	de
805A: E1      		pop 	hl
805B: 7C      		ld 		a,h 							; do MSB
805C: AA      		xor 	d
805D: 67      		ld 		h,a
805E: 7D      		ld 		a,l 							; do LSB
805F: AB      		xor 	e
8060: 18F1    		jr 		__WORD_Logic_Exit
              	
8062:         	WORD_Or:									; <<or>>
8062: D9      		exx
8063: D1      		pop 	de
8064: E1      		pop 	hl
8065: 7C      		ld 		a,h 							; do MSB
8066: B2      		or 		d
8067: 67      		ld 		h,a
8068: 7D      		ld 		a,l 							; do LSB
8069: B3      		or 		e
806A: 18E7    		jr 		__WORD_Logic_Exit
              	
              		include "library/unary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Unary)
              	;
              	; ****************************************************************************************************
              	
              	; abs sgn
              	
806C:         	WORD_0Minus:								; <<0->>
806C: D9      		exx
806D: D1      		pop 	de
806E: 210000  		ld 		hl,0
8071: AF      		xor 	a
8072: ED52    		sbc 	hl,de
8074: E5      		push 	hl
8075: D9      		exx 	
8076: DDE9    		jp 		(ix)
              	
8078:         	WORD_0Equals:
8078: E1      		pop 	hl 								; <<0=>>
8079: 7C      		ld 		a,h
807A: B5      		or 		l
807B: 2806    		jr 		z,__UNPushTrue
807D:         	__UNPushFalse:
807D: 210000  		ld 		hl,0
8080: E5      		push 	hl
8081: DDE9    		jp 		(ix)
8083:         	__UNPushTrue:
8083: 21FFFF  		ld 		hl,0xFFFF
8086:         	__UNPushHLExit	
8086: E5      		push 	hl
8087: DDE9    		jp		(ix)
              	
8089:         	WORD_0LessThan:								; <<0<>>
8089: E1      		pop 	hl
808A: CB7C    		bit 	7,h
808C: 20F5    		jr 		nz,__UNPushTrue
808E: 18ED    		jr 		__UNPushFalse
              	
8090:         	WORD_Abs:									; <<abs>>
8090: E1      		pop 	hl
8091: CB7C    		bit 	7,h 							
8093: 28F1    		jr 		z,__UNPushHLExit 				; if zero push unchanged
8095: E5      		push 	hl
8096: 18D4    		jr	 	WORD_0Minus 					; otherwise do 0-
              	
8098:         	WORD_Sgn:									; <<sgn>>
8098: E1      		pop 	hl
8099: CB7C    		bit 	7,h 							; -ve
809B: 20E6    		jr 		nz,__UNPushTrue
809D: 7C      		ld 		a,h 							; zero
809E: B5      		or 		l
809F: 28DC    		jr 		z,__UNPushFalse
80A1: 210100  		ld 		hl,1 							; +ve push 1
80A4: 18E0    		jr 		__UNPushHLExit
              		
              	; ****************************************************************************************************
              	;
              	;										Arithmetic Quickies
              	;
              	; ****************************************************************************************************
              	
80A6: E1      		pop		hl								; <<1+>>
80A7: 1802    		jr 		__OnePlus
              	
80A9:         	WORD_TwoPlus
80A9: E1      		pop		hl								; <<2+>>
80AA: 23      		inc 	hl
80AB:         	__OnePlus:	
80AB: 23      		inc 	hl
80AC: E5      		push 	hl
80AD: DDE9    		jp 		(ix)
              	
80AF: E1      		pop		hl								; <<1->>
80B0: 1802    		jr 		__OneMinus
              	
80B2: E1      		pop		hl								; <<1->>
80B3: 2B      		dec 	hl
80B4:         	__OneMinus:	
80B4: 2B      		dec 	hl
80B5: E5      		push 	hl
80B6: DDE9    		jp 		(ix)
              	
80B8: E1      		pop		hl 								; <<2*>>
80B9: 1807    		jr 		__TwoTimes
              	
80BB: E1      		pop 	hl								; <<4*>>
80BC: 1803    		jr 		__FourTimes
              	
80BE: E1      		pop		hl 								; <<16*>>
80BF: 29      		add 	hl,hl
80C0: 29      		add 	hl,hl
80C1:         	__FourTimes:
80C1: 29      		add 	hl,hl
80C2:         	__TwoTimes:	
80C2: 29      		add 	hl,hl
80C3: E5      		push 	hl
80C4: DDE9    		jp 		(ix)
              	
80C6: E1      		pop 	hl 								; <<256*>
80C7: 65      		ld	 	h,l
80C8: 2E00    		ld	 	l,0
80CA: E5      		push 	hl
80CB: DDE9    		jp 		(ix)
              	
80CD: E1      		pop 	hl 								; <<2/>>
80CE: 180D    		jr 		__TwoDivide	
              	
80D0: E1      		pop 	hl 								; <<16/>>
              	
80D1: CB2C    		sra 	h
80D3: CB1D    		rr 		l
80D5: CB2C    		sra 	h
80D7: CB1D    		rr 		l
80D9: CB2C    		sra 	h
80DB: CB1D    		rr 		l
              	
80DD:         	__TwoDivide:
80DD: CB2C    		sra 	h
80DF: CB1D    		rr 		l
80E1: E5      		push 	hl
80E2: DDE9    		jp 		(ix)
              	
80E4: E1      		pop 	hl								; <<256/>>
80E5: 6C      		ld	 	l,h
80E6: 2600    		ld 	 	h,0
80E8: CB7D    		bit 	7,l 							; sign extend
80EA: 2801    		jr 		z,__ByteDivideNotSigned
80EC: 25      		dec 	h
80ED:         	__ByteDivideNotSigned: 	
80ED: E5      		push 	hl
80EE: DDE9    		jp 		(ix)
              		include "library/constants.asm"
              	; ****************************************************************************************************
              	;
              	;						Constants, quicker and shorter versions of .literal
              	;
              	; ****************************************************************************************************
              	
              	ConstantWord macro value
              		ld 		hl,&value 						; <<&value>>
              		push 	hl
              		jp 		(ix)
              		endm
              	;
              	;	If you use these (which the compiler does automatically) it saves two bytes over .literal [n]
              	;	and also is several cycles quicker, because it doesn't fetch the value. A similar system is
              	;	used for variables/arrays/constants as these are all 6 bytes long (same as .literal [n] return)
              	;
              		ConstantWord 	-1
80F0: 21FFFF  		ld 		hl,-1 						; <<-1>>
80F3: E5      		push 	hl
80F4: DDE9    		jp 		(ix)
              		ConstantWord 	0	
80F6: 210000  		ld 		hl,0 						; <<0>>
80F9: E5      		push 	hl
80FA: DDE9    		jp 		(ix)
              		ConstantWord 	1
80FC: 210100  		ld 		hl,1 						; <<1>>
80FF: E5      		push 	hl
8100: DDE9    		jp 		(ix)
              		ConstantWord 	2
8102: 210200  		ld 		hl,2 						; <<2>>
8105: E5      		push 	hl
8106: DDE9    		jp 		(ix)
              		ConstantWord 	4
8108: 210400  		ld 		hl,4 						; <<4>>
810B: E5      		push 	hl
810C: DDE9    		jp 		(ix)
              		ConstantWord 	8
810E: 210800  		ld 		hl,8 						; <<8>>
8111: E5      		push 	hl
8112: DDE9    		jp 		(ix)
              		ConstantWord 	10
8114: 210A00  		ld 		hl,10 						; <<10>>
8117: E5      		push 	hl
8118: DDE9    		jp 		(ix)
              		ConstantWord 	16
811A: 211000  		ld 		hl,16 						; <<16>>
811D: E5      		push 	hl
811E: DDE9    		jp 		(ix)
              		ConstantWord 	100
8120: 216400  		ld 		hl,100 						; <<100>>
8123: E5      		push 	hl
8124: DDE9    		jp 		(ix)
              		ConstantWord 	256
8126: 210001  		ld 		hl,256 						; <<256>>
8129: E5      		push 	hl
812A: DDE9    		jp 		(ix)
              	
              		include "library/stack.asm"
              	; ****************************************************************************************************
              	;
              	;										  Stack Manipulation
              	;
              	; ****************************************************************************************************
              	
812C:         	WORD_Dup:									; <<dup>>
812C: E1      		pop 	hl 								; get TOS and push it back twice
812D: E5      		push 	hl
812E: E5      		push 	hl
812F: DDE9    		jp 		(ix) 							; return 
              	
8131:         	WORD_Drop:									; <<drop>>
8131: E1      		pop 	hl
8132: DDE9    		jp 		(ix)
              	
8134:         	WORD_Swap:									; <<swap>>
8134: D9      		exx 									; use alt register set
8135: E1      		pop 	hl 								; get TOS and push it back twice
8136: D1      		pop 	de
8137: E5      		push 	hl
8138: D5      		push 	de
8139: D9      		exx 
813A: DDE9    		jp 		(ix) 							; return 
              	
813C:         	WORD_Over:									; <<over>>
813C: D9      		exx 						
813D: E1      		pop 	hl 								; tos
813E: D1      		pop 	de 								; tos 2
813F: D5      		push 	de 								; push back
8140: E5      		push 	hl
8141: D5      		push 	de 								; with tos 2 on top
8142: D9      		exx
8143: DDE9    		jp 		(ix)
              		include "library/io.asm"
              	; ****************************************************************************************************
              	;
              	;										Input/Output functions
              	;
              	; ****************************************************************************************************
              	
8145:         	WORD_Emit:									; <<emit>>
8145: E1      		pop 	hl 								; get character to print in L
8146: CD8981  		call	PrintCharL
8149: DDE9    		jp 		(ix)
              	
814B:         	WORD_PrintInteger:							; <<.>>
814B: E1      		pop 	hl
814C: CDE781  		call 	PrintInteger
814F: DDE9    		jp 		(ix)
              	
8151:         	WORD_PrintStack:							; <<.stack>>
8151: D5      		push 	de 								; save DE
8152: 210000  		ld 		hl,0  							; get SP into HL
8155: 23      		inc 	hl 								; skip over PUSH DE above
8156: 23      		inc 	hl
8157: 39      		add 	hl,sp
8158: 3E46    		ld  	a,46h 							; first yellow
815A: 323C82  		ld 		(__PCAColour),a
815D:         	__PSLoop:
815D: 5E      		ld 		e,(hl) 							; load into DE
815E: 23      		inc 	hl
815F: 56      		ld 		d,(hl)
8160: 23      		inc 	hl
8161: EB      		ex 		de,hl 							; print it
8162: CDE781  		call 	PrintInteger
8165: EB      		ex 		de,hl
8166: 3E44    		ld  	a,44h 							; remainder green
8168: 323C82  		ld 		(__PCAColour),a
816B: 7C      		ld 		a,h 							; reached top of stack
816C: B7      		or 		a
816D: 20EE    		jr 		nz,__PSLoop
816F: D1      		pop 	de 								; restore DE
8170: 2E0D    		ld 		l,13 							; print CR
8172: CD8981  		call 	PrintCharL
8175: DDE9    		jp 		(ix)
              	
8177:         	WORD_ClearScreen:							; <<cls>>
8177: CD0E82  		call 	ClearScreen
817A: CD2882  		call 	HomeCursor
817D: DDE9    		jp 		(ix)
              	
817F:         	WORD_CR:
817F: FDE9    		jp 		(iy)
8181: 2980    		defw 	Core_Literal
8183: 0D00    		defw 	13
8185: 4581    		defw 	WORD_Emit
8187: 3180    		defw 	Core_Return
              	
              	; ****************************************************************************************************
              	;			This is included if io.asm is included, provides direct I/O to Speccy hardware
              	; ****************************************************************************************************
              	
              		include "utils/screen.asm" 				; Screen I/O routines.
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;			Replacement for Spectrums Screen Display Routine, straight 32x24 video display
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;							Print character in L ; all registers preserved.
              	;
              	; ****************************************************************************************************
              	
8189:         	PrintCharL:
8189: F5      		push 	af 								; stack registers
818A: C5      		push 	bc 								
818B: D5      		push 	de
818C: E5      		push 	hl
              	
818D: 7D      		ld 		a,l 							; check for CR ?
818E: FE0D    		cp 		13
8190: 2847    		jr		z,__PCLReturn
              	
8192: 0600    		ld 		b,0 							; B is the reversing byte
8194: CB7D    		bit 	7,l 							; if bit 7 set
8196: 2803    		jr 		z,__PCANotReverse
8198: 05      		dec 	b 								; B becomes $FF
8199: CBBD    		res 	7,l 							; drop bit 7
819B:         	__PCANotReverse:
819B: 2600    		ld 		h,0 							; HL to 16 bit
819D: ED5B3682		ld 		de,(__PCAFont)					; DE = Font Base
81A1: 29      		add 	hl,hl 							; calc Font Base + char * 8
81A2: 29      		add 	hl,hl
81A3: 29      		add 	hl,hl
81A4: 19      		add 	hl,de
81A5: EB      		ex 		de,hl 							; put in DE
81A6: 2A3882  		ld 		hl,(__PCAVideoPos) 				; get write address
81A9: E5      		push 	hl 								; save for later
81AA:         	_PCALoop:	
81AA: 1A      		ld 		a,(de) 							; read font char
81AB: A8      		xor 	b 								; reverse byte
81AC: 77      		ld 		(hl),a 							; write to screen
81AD: 1C      		inc 	e 								; bump pointers
81AE: 24      		inc 	h
81AF: 7C      		ld 		a,h 							; until done whole row
81B0: E607    		and 	7
81B2: 20F6    		jr 		nz,_PCALoop
              	
              	
81B4: ED5B3A82		ld 		de,(__PCAAttribPos)				; copy colour byte to attribute memory.
81B8: 3A3C82  		ld 		a,(__PCAColour)
81BB: 12      		ld 		(de),a
81BC: 13      		inc 	de
              	
81BD: E1      		pop 	hl 								; restore original video position to HL
81BE: 2C      		inc 	l 								; right one
81BF: 200C    		jr 		nz,__PCANotNewPage 				; if nz don't need new 1/4k page
81C1: 7C      		ld 		a,h 							; advance to next quarter page
81C2: C608    		add 	8
81C4: 67      		ld 		h,a 	
81C5: FE58    		cp 		0x58 							; we only have 3, this is the attribute page
81C7: 2004    		jr 		nz,__PCANotNewPage
81C9: 2640    		ld 		h,0x40 							; wrap round to top.
81CB: 1658    		ld 		d,0x58 							; reset attribute memory pointer
81CD:         	__PCANotNewPage:
81CD: 223882  		ld 		(__PCAVideoPos),hl 				; update new position in video / attr
81D0: ED533A82		ld 		(__PCAAttribPos),de 			
              	
81D4:         	__PCLExit:
81D4: E1      		pop 	hl 								; destack.
81D5: D1      		pop 	de
81D6: C1      		pop 	bc
81D7: F1      		pop 	af
81D8: C9      		ret
              	
81D9:         	__PCLReturn: 								; carriage return.
81D9: 2E20    		ld 		l,' '
81DB: CD8981  		call 	PrintCharL
81DE: 3A3882  		ld 		a,(__PCAVideoPos)
81E1: E61F    		and 	31
81E3: 20F4    		jr 		nz,__PCLReturn
81E5: 18ED    		jr 		__PCLExit
              	
              	; ****************************************************************************************************
              	;
              	;									Print HL in hexadecimal
              	;
              	; ****************************************************************************************************
              	
81E7:         	PrintInteger:
81E7: E5      		push 	hl
81E8: 2E20    		ld 		l,' ' 							; print leading space
81EA: CD8981  		call 	PrintCharL
81ED: E1      		pop 	hl
81EE: 7C      		ld 		a,h
81EF: CDF781  		call 	PrintByteA
81F2: 7D      		ld 		a,l
81F3: CDF781  		call 	PrintByteA
81F6: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;									Print Byte in Hexadecimal
              	;
              	; ****************************************************************************************************
              	
81F7:         	PrintByteA:
81F7: F5      		push 	af 								; save A on stack
81F8: 1F      		rra 									; shift right 4
81F9: 1F      		rra
81FA: 1F      		rra
81FB: 1F      		rra
81FC: CD0082  		call	__PBANibble 					; print it
81FF: F1      		pop 	af 								; restore
8200:         	__PBANibble:
8200: F6F0    		or 		0F0h 							; DAA trick
8202: 27      		daa
8203: C6A0    		add 	a,0A0h
8205: CE40    		adc 	a,040h
8207: E5      		push 	hl 								; print character
8208: 6F      		ld 		l,a
8209: CD8981  		call 	PrintCharL
820C: E1      		pop 	hl
820D: C9      		ret
              	
              	; ****************************************************************************************************
              	;	
              	;											Clear Screen
              	;
              	; ****************************************************************************************************
              	
820E:         	ClearScreen:
820E: E5      		push 	hl
820F: 210040  		ld 		hl,0x4000 						; fill 4000-57FF with zero
8212:         	__CLSLoop1:
8212: 3600    		ld 		(hl),0
8214: 23      		inc 	hl
8215: 7C      		ld 		a,h
8216: FE58    		cp 		0x58
8218: 20F8    		jr		nz,__CLSLoop1
821A:         	__CLSLoop2:									; fill 5800-5FFF with 7 (white)
821A: 3607    		ld 		(hl),7
821C: 23      		inc 	hl
821D: 7C      		ld 		a,h
821E: FE60    		cp 		0x60
8220: 20F8    		jr		nz,__CLSLoop2
8222: 3E01    		ld 		a,1 							; set border to blue.
8224: D3FE    		out 	(0xFE),a
8226: E1      		pop 	hl
8227: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Home Cursor
              	;
              	; ****************************************************************************************************
              	
8228:         	HomeCursor:	
8228: E5      		push 	hl
8229: 210058  		ld 		hl,0x5800 						; reset attribute pos
822C: 223A82  		ld 		(__PCAAttribPos),hl
822F: 2640    		ld 		h,0x40 							; reset video pos
8231: 223882  		ld 		(__PCAVideoPos),hl
8234: E1      		pop 	hl
8235: C9      		ret
              	
8236:         	__PCAFont: 									; font base here
8236: 003C    		defw 	0x3C00
8238:         	__PCAVideoPos: 								; current video memory pointer.
8238: 0040    		defw 	VideoMemory
823A:         	__PCAAttribPos:								; current attribute pointer
823A: 0058    		defw 	AttributeMemory
823C:         	__PCAColour: 								; current colour to use
823C: 44      		defb 	0x44
              		include "library/misc.asm"
              	; ****************************************************************************************************
              	;
              	; 												Miscellany
              	;
              	; ****************************************************************************************************
              	
823D:         	WORD_Stop:									; <<stop>>
823D: 18FE    		jr 		WORD_Stop
              	
              	
              	
823F:         	BootWord:
823F: FDE9    		jp 			(iy)
8241: 7781    		defw 		WORD_ClearScreen
8243: 6382    		defw 		WORD_Star
8245: 6382    		defw 		WORD_Star
8247: 6382    		defw 		WORD_Star
8249: 7F81    		defw 		WORD_CR
              	
824B: 2980    		defw 		Core_Literal
824D: 0100    		defw 		1
824F: 2980    		defw 		Core_Literal
8251: 0200    		defw 		2
8253: 2980    		defw 		Core_Literal
8255: 0300    		defw 		3
8257: 2980    		defw 		Core_Literal
8259: 0400    		defw 		4
825B: 5181    		defw 		WORD_PrintStack
825D: 3C81    		defw		WORD_Over
825F: 5181    		defw 		WORD_PrintStack
8261: 3D82    		defw 		WORD_Stop
              	
8263:         	WORD_Star:
8263: FDE9    		jp 			(iy)
8265: 2980    		defw 		Core_Literal
8267: 2A00    		defw 		42
8269: 4581    		defw 		WORD_Emit
826B: 3180    		defw 		Core_Return
              	
826D:         	EndOfCode:
              	
              	; ****************************************************************************************************
              	;
              	;												Examples
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	Code word (example) DUP. Note that in code words DE is the code pointer.
              	;	We just go straight in with the machine code. Code words can only use HL as a temporary value
              	; 	so for things like + use EXX and do it in the alternate set.
              	;
              	;
              	;dup:										; <<dup>>
              	;	pop 	hl
              	;	push 	hl
              	;	push 	hl
              	;	jp		(ix)							; and fix up so HL is the code pointer again and loop
              	;
              	;
              	;
              	;	Word built up out of other definitions.
              	;	
              	;	jp 		(iy)							; identifies as a word from words.
              	;
              	;	; first def addr
              	;	; second def addr
              	;	;	..
              	;	;	..
              	;
              	;	defw 	Core_Return 					; now we want to go back.
              	;
              	
              	
              	


total time: 0.0014 sec.
no errors
