              	; --------------------------------------
              	; zasm: assemble "forth.asm"
              	; date: 2017-05-16 15:34:08
              	; --------------------------------------


              	; ****************************************************************************************************
              	;
              	;									Forth Compiler Runtime
              	;
              	; ****************************************************************************************************
              	
              		include 	"sna_header.asm"			; .SNA boot header
              	; *****************************************************************************************
              	; *****************************************************************************************
              	;
              	;                       SNA Header - variant of the provided example.
              	;
              	; *****************************************************************************************
              	; *****************************************************************************************
              	
              	#target sna
              	
              	; *****************************************************************************************
              	;
              	;                               saved registers, restored in NMI
              	;
              	; *****************************************************************************************
              	
0000:         	#code HEAD, 0, 27
0000: 3F      	    defb    $3f             ; i
0001: 0000    	    defw    0               ; hl'
0003: 0000    	    defw    0               ; de'
0005: 0000    	    defw    0               ; bc'
0007: 0000    	    defw    0               ; af'
              	
0009: 0000    	    defw    0               ; hl
000B: 0000    	    defw    0               ; de
000D: 0000    	    defw    0               ; bc
000F: 0000    	    defw    0               ; iy
0011: 0000    	    defw    0               ; ix
              	
0013: 00      	    defb    0<<2            ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei
0014: 000000  	    defb    0,0,0           ; r,f,a
0017: 035B    	    defw    __stackEnd      ; sp
0019: 01      	    defb    1               ; irpt mode
001A: 00      	    defb    0               ; border color: 0=black ... 7=white
              	
              	; *****************************************************************************************
              	;
              	;                   $4000-$7FFF. Pixel Memory, Attribute Memory, Slow RAM
              	;
              	; *****************************************************************************************
              	
4000:         	#code SLOW_RAM, 0x4000, 0x4000
              	
4000:         	VideoMemory:
4000: 00000000	    defs    0x1800
4004: 00...   	
5800:         	AttributeMemory:
5800: 00000000	    defs    0x300
5804: 00...   	
5B00:         	EndVideoMemory:
              	
5B00:         	__bootSNA:
5B00: C30480  	    jp      start
              	
              	; *****************************************************************************************
              	;
              	;                            $8000-$FFFF. Non contentious memory
              	;
              	; *****************************************************************************************
              	
5B03:         	__stackEnd:   
5B03: 005B    	    defw    __bootSNA
              	
8000:         	#code FAST_RAM, 0x8000, 0x8000
              	
              		include 	"core4.asm" 				; Forth core (Direct Threaded)
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;													Core v4
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;	These words are accessed/changed by the compiler, so it knows (i) where to start the program
              	;	and (ii) where it can compile code.
              	;
              	; ****************************************************************************************************
              	
8000:         	BootAddress:
8000: 1884    		defw 	BootWord 						; start of threaded word.
8002:         	FreeAddress:
8002: 2E84    		defw 	EndOfCode 						; end of code that is built with the assembler.
              	
              	; ****************************************************************************************************
              	;
              	;										Start Forth Core
              	;
              	; ****************************************************************************************************
              		
8004:         	start:
8004: DD212280		ld 		ix,Core_Continue  				; these allow us to do fast jumps in and out of routines.
8008: FD211980		ld 		iy,Core_Call 					; also saving a byte on long jumps.
              	
800C: 310000  		ld 		sp,0x0000 						; sp is the data stack (works down)
800F: 0100FF  		ld 		bc,0xFF00 						; bc is the return stack (works up)
              	
8012: 2A0080  		ld 		hl,(BootAddress)				; hl is the IP (except when executing Z80 code words)
8015: 23      		inc 	hl 								; skip over the JP (IY)
8016: 23      		inc 	hl
8017: 180A    		jr 		Core_Execute
              	
              	; ****************************************************************************************************
              	;
              	;		The JP (IY) at the start of a threaded definition comes here. DE contains
              	; 		the old address, HL the new one.
              	;
              	;		Save the calling address on the stack and execute from HL. Which handily is in HL.
              	;
              	; ****************************************************************************************************
              	
8019:         	Core_Call:
8019: 23      		inc 	hl 								; advance HL over the JP(IY) $FD $E9
801A: 23      		inc 	hl 								; now points to the first definition
              	
801B: 7B      		ld 		a,e 							; push DE (old address) on the BC stack.
801C: 03      		inc 	bc 								; unfortunately a Z80 only has one stack, so we have
801D: 02      		ld 		(bc),a 							; to use it for either data *or* return.
801E: 7A      		ld 		a,d
801F: 03      		inc 	bc
8020: 02      		ld 		(bc),a
              	
8021: EB      		ex 		de,hl 							; allows us to fall through to execute loop
              	
              	; ****************************************************************************************************
              	;
              	;	Ending a machine code definition comes here (using JP (IX)). We need this exchange
              	; 	because when running m/c definition DE is the instruction pointer
              	;
              	; ****************************************************************************************************
              	
8022:         	Core_Continue:
8022: EB      		ex 		de,hl 							; if executing code word come back here.
              	
              	; ****************************************************************************************************
              	;
              	;					Main execution entry point. Execute instruction at (DE)
              	;
              	; ****************************************************************************************************
              	
8023:         	Core_Execute:
8023: 5E      		ld 		e,(hl)							; read address of next word at HL into DE, LSB first
8024: 23      		inc 	hl
8025: 56      		ld 		d,(hl)
8026: 23      		inc 	hl
8027: EB      		ex 		de,hl 							; swap so when executing code word DE code ptr and so we can 
8028: E9      		jp 		(hl) 							; do this 4 cycle jump
              	
              	; ****************************************************************************************************
              	;
              	;											16 bit literal word
              	;
              	; ****************************************************************************************************
              	
8029:         	Core_Literal:								; <<.literal>>
8029: EB      		ex 		de,hl 							; HL now contains the IP back again.
802A: 5E      		ld 		e,(hl) 							; load next word into DE
802B: 23      		inc 	hl
802C: 56      		ld 		d,(hl)
802D: 23      		inc 	hl
802E: D5      		push 	de 								; push word on data stack
802F: 18F2    		jr 		Core_Execute 					; and execute without doing the DE/HL swap
              	
              	; ****************************************************************************************************
              	;
              	;												Return word.
              	;
              	; ****************************************************************************************************
              	
8031:         	Core_Return:								; <<;>>
8031: 0A      		ld 		a,(bc) 							; pop address into DE.
8032: 0B      		dec 	bc
8033: 57      		ld 		d,a 
8034: 0A      		ld 		a,(bc)
8035: 0B      		dec 	bc
8036: 5F      		ld 		e,a
8037: DDE9    		jp 		(ix) 							; this will put DE -> HL and start executing one level up.
              	
              		include 	"library.asm" 				; Basic FORTH words including optional text/sprite stuff
              	; ****************************************************************************************************
              	;
              	;								 Basic FORTH Library, Z80 Assembler
              	;
              	; ****************************************************************************************************
              	
              		include "library/binary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Binary)
              	;
              	; ****************************************************************************************************
              	
8039:         	WORD_Add:									; <<+>>
8039: D9      		exx 
803A: E1      		pop		hl
803B: D1      		pop 	de
803C: 19      		add 	hl,de
803D: E5      		push 	hl
803E: D9      		exx
803F: DDE9    		jp 		(ix)
              	
8041:         	WORD_Subtract: 								; <<->>
8041: D9      		exx 
8042: D1      		pop 	de
8043: E1      		pop 	hl
8044: AF      		xor 	a
8045: ED52    		sbc 	hl,de
8047: E5      		push 	hl
8048: D9      		exx 	
8049: DDE9    		jp 		(ix)
              	
804B:         	WORD_And:									; <<and>>
804B: D9      		exx
804C: D1      		pop 	de
804D: E1      		pop 	hl
804E: 7C      		ld 		a,h 							; do MSB
804F: A2      		and 	d
8050: 67      		ld 		h,a
8051: 7D      		ld 		a,l 							; do LSB
8052: A3      		and 	e
8053:         	__WORD_Logic_Exit:
8053: 6F      		ld 		l,a 							
8054: E5      		push 	hl
8055: D9      		exx
8056: DDE9    		jp 		(ix)
              	
8058:         	WORD_Xor:									; <<xor>>
8058: D9      		exx
8059: D1      		pop 	de
805A: E1      		pop 	hl
805B: 7C      		ld 		a,h 							; do MSB
805C: AA      		xor 	d
805D: 67      		ld 		h,a
805E: 7D      		ld 		a,l 							; do LSB
805F: AB      		xor 	e
8060: 18F1    		jr 		__WORD_Logic_Exit
              	
8062:         	WORD_Or:									; <<or>>
8062: D9      		exx
8063: D1      		pop 	de
8064: E1      		pop 	hl
8065: 7C      		ld 		a,h 							; do MSB
8066: B2      		or 		d
8067: 67      		ld 		h,a
8068: 7D      		ld 		a,l 							; do LSB
8069: B3      		or 		e
806A: 18E7    		jr 		__WORD_Logic_Exit
              	
              		include "library/unary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Unary)
              	;
              	; ****************************************************************************************************
              	
              	; abs sgn
              	
806C:         	WORD_0Minus:								; <<0->>
806C: D9      		exx
806D: D1      		pop 	de
806E: 210000  		ld 		hl,0
8071: AF      		xor 	a
8072: ED52    		sbc 	hl,de
8074: E5      		push 	hl
8075: D9      		exx 	
8076: DDE9    		jp 		(ix)
              	
8078:         	WORD_0Equals:
8078: E1      		pop 	hl 								; <<0=>>
8079: 7C      		ld 		a,h
807A: B5      		or 		l
807B: 2806    		jr 		z,__UNPushTrue
807D:         	__UNPushFalse:
807D: 210000  		ld 		hl,0
8080: E5      		push 	hl
8081: DDE9    		jp 		(ix)
8083:         	__UNPushTrue:
8083: 21FFFF  		ld 		hl,0xFFFF
8086:         	__UNPushHLExit	
8086: E5      		push 	hl
8087: DDE9    		jp		(ix)
              	
8089:         	WORD_0LessThan:								; <<0<>>
8089: E1      		pop 	hl
808A: CB7C    		bit 	7,h
808C: 20F5    		jr 		nz,__UNPushTrue
808E: 18ED    		jr 		__UNPushFalse
              	
8090:         	WORD_Abs:									; <<abs>>
8090: E1      		pop 	hl
8091: CB7C    		bit 	7,h 							
8093: 28F1    		jr 		z,__UNPushHLExit 				; if zero push unchanged
8095: E5      		push 	hl
8096: 18D4    		jr	 	WORD_0Minus 					; otherwise do 0-
              	
8098:         	WORD_Sgn:									; <<sgn>>
8098: E1      		pop 	hl
8099: CB7C    		bit 	7,h 							; -ve
809B: 20E6    		jr 		nz,__UNPushTrue
809D: 7C      		ld 		a,h 							; zero
809E: B5      		or 		l
809F: 28DC    		jr 		z,__UNPushFalse
80A1: 210100  		ld 		hl,1 							; +ve push 1
80A4: 18E0    		jr 		__UNPushHLExit
              		
              	; ****************************************************************************************************
              	;
              	;										Arithmetic Quickies
              	;
              	; ****************************************************************************************************
              	
80A6:         	WORD_OnePlus:
80A6: E1      		pop		hl								; <<1+>>
80A7: 1802    		jr 		__OnePlus
              	
80A9:         	WORD_TwoPlus:
80A9: E1      		pop		hl								; <<2+>>
80AA: 23      		inc 	hl
80AB:         	__OnePlus:	
80AB: 23      		inc 	hl
80AC: E5      		push 	hl
80AD: DDE9    		jp 		(ix)
              	
80AF: E1      		pop		hl								; <<1->>
80B0: 1802    		jr 		__OneMinus
              	
80B2: E1      		pop		hl								; <<1->>
80B3: 2B      		dec 	hl
80B4:         	__OneMinus:	
80B4: 2B      		dec 	hl
80B5: E5      		push 	hl
80B6: DDE9    		jp 		(ix)
              	
80B8: E1      		pop		hl 								; <<2*>>
80B9: 1807    		jr 		__TwoTimes
              	
80BB: E1      		pop 	hl								; <<4*>>
80BC: 1803    		jr 		__FourTimes
              	
80BE: E1      		pop		hl 								; <<16*>>
80BF: 29      		add 	hl,hl
80C0: 29      		add 	hl,hl
80C1:         	__FourTimes:
80C1: 29      		add 	hl,hl
80C2:         	__TwoTimes:	
80C2: 29      		add 	hl,hl
80C3: E5      		push 	hl
80C4: DDE9    		jp 		(ix)
              	
80C6: E1      		pop 	hl 								; <<256*>
80C7: 65      		ld	 	h,l
80C8: 2E00    		ld	 	l,0
80CA: E5      		push 	hl
80CB: DDE9    		jp 		(ix)
              	
80CD: E1      		pop 	hl 								; <<2/>>
80CE: 180D    		jr 		__TwoDivide	
              	
80D0: E1      		pop 	hl 								; <<16/>>
              	
80D1: CB2C    		sra 	h
80D3: CB1D    		rr 		l
80D5: CB2C    		sra 	h
80D7: CB1D    		rr 		l
80D9: CB2C    		sra 	h
80DB: CB1D    		rr 		l
              	
80DD:         	__TwoDivide:
80DD: CB2C    		sra 	h
80DF: CB1D    		rr 		l
80E1: E5      		push 	hl
80E2: DDE9    		jp 		(ix)
              	
80E4: E1      		pop 	hl								; <<256/>>
80E5: 6C      		ld	 	l,h
80E6: 2600    		ld 	 	h,0
80E8: CB7D    		bit 	7,l 							; sign extend
80EA: 2801    		jr 		z,__ByteDivideNotSigned
80EC: 25      		dec 	h
80ED:         	__ByteDivideNotSigned: 	
80ED: E5      		push 	hl
80EE: DDE9    		jp 		(ix)
              		include "library/constants.asm"
              	; ****************************************************************************************************
              	;
              	;						Constants, quicker and shorter versions of .literal
              	;
              	; ****************************************************************************************************
              	
              	ConstantWord macro value
              		ld 		hl,&value 						; <<&value>>
              		push 	hl
              		jp 		(ix)
              		endm
              	;
              	;	If you use these (which the compiler does automatically) it saves two bytes over .literal [n]
              	;	and also is several cycles quicker, because it doesn't fetch the value. A similar system is
              	;	used for variables/arrays/constants as these are all 6 bytes long (same as .literal [n] return)
              	;
              		ConstantWord 	-1
80F0: 21FFFF  		ld 		hl,-1 						; <<-1>>
80F3: E5      		push 	hl
80F4: DDE9    		jp 		(ix)
              		ConstantWord 	0	
80F6: 210000  		ld 		hl,0 						; <<0>>
80F9: E5      		push 	hl
80FA: DDE9    		jp 		(ix)
              		ConstantWord 	1
80FC: 210100  		ld 		hl,1 						; <<1>>
80FF: E5      		push 	hl
8100: DDE9    		jp 		(ix)
              		ConstantWord 	2
8102: 210200  		ld 		hl,2 						; <<2>>
8105: E5      		push 	hl
8106: DDE9    		jp 		(ix)
              		ConstantWord 	4
8108: 210400  		ld 		hl,4 						; <<4>>
810B: E5      		push 	hl
810C: DDE9    		jp 		(ix)
              		ConstantWord 	8
810E: 210800  		ld 		hl,8 						; <<8>>
8111: E5      		push 	hl
8112: DDE9    		jp 		(ix)
              		ConstantWord 	10
8114: 210A00  		ld 		hl,10 						; <<10>>
8117: E5      		push 	hl
8118: DDE9    		jp 		(ix)
              		ConstantWord 	16
811A: 211000  		ld 		hl,16 						; <<16>>
811D: E5      		push 	hl
811E: DDE9    		jp 		(ix)
              		ConstantWord 	100
8120: 216400  		ld 		hl,100 						; <<100>>
8123: E5      		push 	hl
8124: DDE9    		jp 		(ix)
              		ConstantWord 	256
8126: 210001  		ld 		hl,256 						; <<256>>
8129: E5      		push 	hl
812A: DDE9    		jp 		(ix)
              	
              		include "library/stack.asm"
              	; ****************************************************************************************************
              	;
              	;										  Stack Manipulation
              	;
              	; ****************************************************************************************************
              	
812C:         	WORD_Dup:									; <<dup>>
812C: E1      		pop 	hl 								; get TOS and push it back twice
812D: E5      		push 	hl
812E: E5      		push 	hl
812F: DDE9    		jp 		(ix) 							; return 
              	
8131:         	WORD_Drop:									; <<drop>>
8131: E1      		pop 	hl
8132: DDE9    		jp 		(ix)
              	
8134:         	WORD_Swap:									; <<swap>>
8134: D9      		exx 									; use alt register set
8135: E1      		pop 	hl 								; get TOS and push it back twice
8136: D1      		pop 	de
8137: E5      		push 	hl
8138: D5      		push 	de
8139: D9      		exx 
813A: DDE9    		jp 		(ix) 							; return 
              	
813C:         	WORD_Over:									; <<over>>
813C: D9      		exx 						
813D: E1      		pop 	hl 								; tos
813E: D1      		pop 	de 								; tos 2
813F: D5      		push 	de 								; push back
8140: E5      		push 	hl
8141: D5      		push 	de 								; with tos 2 on top
8142: D9      		exx
8143: DDE9    		jp 		(ix)
              	
8145:         	WORD_Rot:									; <<rot>>
8145: D9      		exx
8146: E1      		pop 	hl 								; X3  X1 X2 X3 -> X2 X3 X1
8147: D1      		pop 	de 								; X2 
8148: C1      		pop		bc 								; X1
8149: D5      		push 	de
814A: E5      		push 	hl
814B: C5      		push 	bc
814C: D9      		exx
814D: DDE9    		jp 		(ix)
              	
814F:         	WORD_Pick:									; <<pick>>
814F: D9      		exx 		
8150: E1      		pop 	hl 								; get the index off the stack
8151: 39      		add 	hl,sp 							; add stack offset
8152: 56      		ld 		d,(hl) 							; read stack value
8153: 23      		inc 	hl
8154: 5E      		ld 		e,(hl)
8155: D5      		push 	de 								; push on the stack
8156: D9      		exx
8157: DDE9    		jp 		(ix)
              		include "library/misc.asm"
              	; ****************************************************************************************************
              	;
              	; 												Miscellany
              	;
              	; ****************************************************************************************************
              	
8159:         	WORD_Branch:								; <<[br]>>
8159: EB      		ex 	 	de,hl 							; HL now points to the next word
815A: 5E      		ld 		e,(hl)							; read into DE
815B: 23      		inc 	hl
815C: 56      		ld 		d,(hl)
815D: DDE9    		jp 		(ix) 							; and go there.
              	
815F:         	WORD_BranchZero:
815F: E1      		pop 	hl 								; non destructive test of TOS
8160: E5      		push 	hl
8161: 7C      		ld 		a,h 							; branch if zero.
8162: B5      		or 		l
8163: 28F4    		jr 		z,WORD_Branch
8165:         	__WORD_BranchFail:							; if non zero
8165: 13      		inc 	de 								; skip over jump address
8166: 13      		inc 	de
8167: DDE9    		jp 		(ix)
              	
8169:         	WORD_BranchPositive:
8169: E1      		pop 	hl 								; non destructive test of TOS
816A: E5      		push 	hl
816B: CB7C    		bit 	7,h 							; if +ve branch
816D: 28EA    		jr 		z,WORD_Branch
816F: 18F4    		jr 		__WORD_BranchFail 				; if -ve don't
              	
8171:         	WORD_Stop:									; <<stop>>
8171: 18FE    		jr 		WORD_Stop
              	
8173:         	WORD_RStoDS:								; <<r>>>
8173: 0A      		ld 		a,(bc) 							; pop address into HL
8174: 0B      		dec 	bc
8175: 67      		ld 		h,a 
8176: 0A      		ld 		a,(bc)
8177: 0B      		dec 	bc
8178: 6F      		ld 		l,a
8179: E5      		push 	hl 								; push on data stack.
817A: DDE9    		jp 		(ix)
              	
817C:         	WORD_DStoRS:								; <<>r>>
817C: E1      		pop 	hl 								; get top of data stack
817D: 03      		inc 	bc 								; push on return stack.
817E: 7D      		ld 		a,l
817F: 02      		ld 		(bc),a
8180: 03      		inc 	bc
8181: 7C      		ld 		a,h
8182: 02      		ld 		(bc),a
8183: DDE9    		jp 		(ix)
              	
8185:         	WORD_RDrop:									; <<rdrop>>
8185: 0B      		dec 	bc
8186: 0B      		dec 	bc
8187: DDE9    		jp 		(ix)
              	
              	; ****************************************************************************************************
              	;
              	;	These routines are (potentially) common to any graphics routines, so are placed here. At the
              	;
              	;	present time both are only used by 'Sprite'
              	;
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;		Calculate Pixel Address (DE)  Attribute Address (HL) for Pixel (B,C). Return CY=0 if bad 
              	;
              	; ****************************************************************************************************
              	
8189:         	CalculatePixelAndAttrAddress:
8189: 79      		ld 		a,c 							; check Y on screen
818A: FEC0    		cp 		192
818C: D0      		ret 	nc 								; if >= 24*8 then exit now.	
              	
818D: E607    		and 	7 								; get the three low bits.
818F: 67      		ld  	h,a 							; goes in H bits 2..0
              	
8190: 79      		ld 		a,c 							; we want bits 7..6 to be in 4..3
8191: 1F      		rra 									; in 6..5
8192: 1F      		rra 									; in 5..4
8193: 1F      		rra										; in 4..3
              	
8194: E618    		and 	018h 							; isolate
8196: B4      		or 		h 								; or with H
8197: F640    		or 		040h 							; set bit 6
8199: 67      		ld 		h,a 							; and copy back.
              	
819A: 79      		ld 		a,c 							; we want bits 5,4,3 to be in slots 7,6,5
819B: 87      		add 	a,a
819C: 87      		add 	a,a
819D: E6E0    		and 	0E0h
819F: 6F      		ld 		l,a 							; save in L
              	
81A0: 78      		ld 		a,b 							; get X bits 7..3 - 4..0
81A1: 1F      		rra
81A2: 1F      		rra
81A3: 1F      		rra	
81A4: E61F    		and 	1Fh
81A6: 5F      		ld 		e,a 							; save X/8 in E
              	
81A7: B5      		or  	l 								; or into L and write back
81A8: 6F      		ld  	l,a 							; HL now is the base graphic
81A9: E5      		push 	hl
              	
81AA: DD7E01  		ld 		a,(ix+1) 						; get Y
81AD: E6F8    		and 	0F8h							; now (Y / 8) * 8
81AF: 6F      		ld 		l,a
81B0: 2600    		ld 		h,0
81B2: 29      		add 	hl,hl 						
81B3: 29      		add 	hl,hl 							; now (Y / 8) * 32
              	
81B4: 1658    		ld 		d,058h 							; B = $5800 + (X / 8)
81B6: 19      		add 	hl,de
81B7: D1      		pop 	de
81B8: 37      		scf
81B9: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;		Advance the line address HL down by 1, handles the slightly odd screen arrangement
              	;
              	;							If CY clear, then we have changed attribute byte.
              	;
              	; ****************************************************************************************************
              	
81BA:         	MovePixelAddressDown:
81BA: 24      		inc 	h 								; next line down.
81BB: 7C      		ld 		a,h 							; have we stepped over the border
81BC: E607    		and 	7
81BE: 37      		scf 									; if we haven't, return with CY set.
81BF: C0      		ret 	nz
              	
81C0: 7C      		ld 		a,h 							; fix up three lower bits of high address byte
81C1: D608    		sub 	8
81C3: 67      		ld 		h,a
              	
81C4: 7D      		ld 		a,l 							; next block of 8 down, high 3 bits of low address byte
81C5: C620    		add 	32
81C7: 6F      		ld 		l,a
81C8: D0      		ret		nc
              	
81C9: 7C      		ld 		a,h 							; next page down ; also it will clear the carry.
81CA: C608    		add 	8
81CC: 67      		ld 		h,a
81CD: C9      		ret
              	
              		
              		include "library/io.asm"
              	; ****************************************************************************************************
              	;
              	;										Input/Output functions
              	;
              	; ****************************************************************************************************
              	
81CE:         	WORD_Emit:									; <<emit>>
81CE: E1      		pop 	hl 								; get character to print in L
81CF: CD1282  		call	PrintCharL
81D2: DDE9    		jp 		(ix)
              	
81D4:         	WORD_PrintInteger:							; <<.>>
81D4: E1      		pop 	hl
81D5: CD7082  		call 	PrintInteger
81D8: DDE9    		jp 		(ix)
              	
81DA:         	WORD_PrintStack:							; <<.stack>>
81DA: D5      		push 	de 								; save DE
81DB: 210000  		ld 		hl,0  							; get SP into HL
81DE: 23      		inc 	hl 								; skip over PUSH DE above
81DF: 23      		inc 	hl
81E0: 39      		add 	hl,sp
81E1: 3E46    		ld  	a,46h 							; first yellow
81E3: 32C582  		ld 		(__PCAColour),a
81E6:         	__PSLoop:
81E6: 5E      		ld 		e,(hl) 							; load into DE
81E7: 23      		inc 	hl
81E8: 56      		ld 		d,(hl)
81E9: 23      		inc 	hl
81EA: EB      		ex 		de,hl 							; print it
81EB: CD7082  		call 	PrintInteger
81EE: EB      		ex 		de,hl
81EF: 3E44    		ld  	a,44h 							; remainder green
81F1: 32C582  		ld 		(__PCAColour),a
81F4: 7C      		ld 		a,h 							; reached top of stack
81F5: B7      		or 		a
81F6: 20EE    		jr 		nz,__PSLoop
81F8: D1      		pop 	de 								; restore DE
81F9: 2E0D    		ld 		l,13 							; print CR
81FB: CD1282  		call 	PrintCharL
81FE: DDE9    		jp 		(ix)
              	
8200:         	WORD_ClearScreen:							; <<cls>>
8200: CD9782  		call 	ClearScreen
8203: CDB182  		call 	HomeCursor
8206: DDE9    		jp 		(ix)
              	
8208:         	WORD_CR:									; <<cr>>
8208: FDE9    		jp 		(iy)
820A: 2980    		defw 	Core_Literal
820C: 0D00    		defw 	13
820E: CE81    		defw 	WORD_Emit
8210: 3180    		defw 	Core_Return
              	
              	; ****************************************************************************************************
              	;			This is included if io.asm is included, provides direct I/O to Speccy hardware
              	; ****************************************************************************************************
              	
              		include "utils/screen.asm" 				; Screen I/O routines.
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;			Replacement for Spectrums Screen Display Routine, straight 32x24 video display
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;							Print character in L ; all registers preserved.
              	;
              	; ****************************************************************************************************
              	
8212:         	PrintCharL:
8212: F5      		push 	af 								; stack registers
8213: C5      		push 	bc 								
8214: D5      		push 	de
8215: E5      		push 	hl
              	
8216: 7D      		ld 		a,l 							; check for CR ?
8217: FE0D    		cp 		13
8219: 2847    		jr		z,__PCLReturn
              	
821B: 0600    		ld 		b,0 							; B is the reversing byte
821D: CB7D    		bit 	7,l 							; if bit 7 set
821F: 2803    		jr 		z,__PCANotReverse
8221: 05      		dec 	b 								; B becomes $FF
8222: CBBD    		res 	7,l 							; drop bit 7
8224:         	__PCANotReverse:
8224: 2600    		ld 		h,0 							; HL to 16 bit
8226: ED5BBF82		ld 		de,(__PCAFont)					; DE = Font Base
822A: 29      		add 	hl,hl 							; calc Font Base + char * 8
822B: 29      		add 	hl,hl
822C: 29      		add 	hl,hl
822D: 19      		add 	hl,de
822E: EB      		ex 		de,hl 							; put in DE
822F: 2AC182  		ld 		hl,(__PCAVideoPos) 				; get write address
8232: E5      		push 	hl 								; save for later
8233:         	_PCALoop:	
8233: 1A      		ld 		a,(de) 							; read font char
8234: A8      		xor 	b 								; reverse byte
8235: 77      		ld 		(hl),a 							; write to screen
8236: 1C      		inc 	e 								; bump pointers
8237: 24      		inc 	h
8238: 7C      		ld 		a,h 							; until done whole row
8239: E607    		and 	7
823B: 20F6    		jr 		nz,_PCALoop
              	
              	
823D: ED5BC382		ld 		de,(__PCAAttribPos)				; copy colour byte to attribute memory.
8241: 3AC582  		ld 		a,(__PCAColour)
8244: 12      		ld 		(de),a
8245: 13      		inc 	de
              	
8246: E1      		pop 	hl 								; restore original video position to HL
8247: 2C      		inc 	l 								; right one
8248: 200C    		jr 		nz,__PCANotNewPage 				; if nz don't need new 1/4k page
824A: 7C      		ld 		a,h 							; advance to next quarter page
824B: C608    		add 	8
824D: 67      		ld 		h,a 	
824E: FE58    		cp 		0x58 							; we only have 3, this is the attribute page
8250: 2004    		jr 		nz,__PCANotNewPage
8252: 2640    		ld 		h,0x40 							; wrap round to top.
8254: 1658    		ld 		d,0x58 							; reset attribute memory pointer
8256:         	__PCANotNewPage:
8256: 22C182  		ld 		(__PCAVideoPos),hl 				; update new position in video / attr
8259: ED53C382		ld 		(__PCAAttribPos),de 			
              	
825D:         	__PCLExit:
825D: E1      		pop 	hl 								; destack.
825E: D1      		pop 	de
825F: C1      		pop 	bc
8260: F1      		pop 	af
8261: C9      		ret
              	
8262:         	__PCLReturn: 								; carriage return.
8262: 2E20    		ld 		l,' '
8264: CD1282  		call 	PrintCharL
8267: 3AC182  		ld 		a,(__PCAVideoPos)
826A: E61F    		and 	31
826C: 20F4    		jr 		nz,__PCLReturn
826E: 18ED    		jr 		__PCLExit
              	
              	; ****************************************************************************************************
              	;
              	;									Print HL in hexadecimal
              	;
              	; ****************************************************************************************************
              	
8270:         	PrintInteger:
8270: E5      		push 	hl
8271: 2E20    		ld 		l,' ' 							; print leading space
8273: CD1282  		call 	PrintCharL
8276: E1      		pop 	hl
8277: 7C      		ld 		a,h
8278: CD8082  		call 	PrintByteA
827B: 7D      		ld 		a,l
827C: CD8082  		call 	PrintByteA
827F: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;									Print Byte in Hexadecimal
              	;
              	; ****************************************************************************************************
              	
8280:         	PrintByteA:
8280: F5      		push 	af 								; save A on stack
8281: 1F      		rra 									; shift right 4
8282: 1F      		rra
8283: 1F      		rra
8284: 1F      		rra
8285: CD8982  		call	__PBANibble 					; print it
8288: F1      		pop 	af 								; restore
8289:         	__PBANibble:
8289: F6F0    		or 		0F0h 							; DAA trick
828B: 27      		daa
828C: C6A0    		add 	a,0A0h
828E: CE40    		adc 	a,040h
8290: E5      		push 	hl 								; print character
8291: 6F      		ld 		l,a
8292: CD1282  		call 	PrintCharL
8295: E1      		pop 	hl
8296: C9      		ret
              	
              	; ****************************************************************************************************
              	;	
              	;											Clear Screen
              	;
              	; ****************************************************************************************************
              	
8297:         	ClearScreen:
8297: E5      		push 	hl
8298: 210040  		ld 		hl,0x4000 						; fill 4000-57FF with zero
829B:         	__CLSLoop1:
829B: 3600    		ld 		(hl),0
829D: 23      		inc 	hl
829E: 7C      		ld 		a,h
829F: FE58    		cp 		0x58
82A1: 20F8    		jr		nz,__CLSLoop1
82A3:         	__CLSLoop2:									; fill 5800-5FFF with 7 (white)
82A3: 3607    		ld 		(hl),7
82A5: 23      		inc 	hl
82A6: 7C      		ld 		a,h
82A7: FE5B    		cp 		0x5B
82A9: 20F8    		jr		nz,__CLSLoop2
82AB: 3E01    		ld 		a,1 							; set border to blue.
82AD: D3FE    		out 	(0xFE),a
82AF: E1      		pop 	hl
82B0: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Home Cursor
              	;
              	; ****************************************************************************************************
              	
82B1:         	HomeCursor:	
82B1: E5      		push 	hl
82B2: 210058  		ld 		hl,0x5800 						; reset attribute pos
82B5: 22C382  		ld 		(__PCAAttribPos),hl
82B8: 2640    		ld 		h,0x40 							; reset video pos
82BA: 22C182  		ld 		(__PCAVideoPos),hl
82BD: E1      		pop 	hl
82BE: C9      		ret
              	
82BF:         	__PCAFont: 									; font base here
82BF: 003C    		defw 	0x3C00
82C1:         	__PCAVideoPos: 								; current video memory pointer.
82C1: 0040    		defw 	VideoMemory
82C3:         	__PCAAttribPos:								; current attribute pointer
82C3: 0058    		defw 	AttributeMemory
82C5:         	__PCAColour: 								; current colour to use
82C5: 44      		defb 	0x44
              		include "library/sprites.asm"
              	; ****************************************************************************************************
              	;
              	;										16 x 16 Sprite Words
              	;
              	; ****************************************************************************************************
              	
              		include 	"utils/sprites16x16.asm"
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;										16 x 16 Sprite Routines
              	;
              	;	These sprites are simple 16x16 XOR which restore the background attributes from a shadow of 
              	;	$5800-$5B00 at $5C00-$5F00. It is designed to operate not dissimilarly to the Next ; pure 
              	; 	XOR sprites can be removed and moved in any order you like.
              	;
              	;	There is some self modifying code here - the pointers are all kept in SMC, so is the counter
              	;	and it is also used to modify the 24 bit shifter.
              	;
              	;	On a stock Spectrum (Fuse) can do about 500 draws/erases a second.
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;	
              	;	IX points to the sprite data, as follows.
              	;
              	;	+0 			X position (0-255)
              	;	+1 			Y position (0-191)
              	;	+2 			Drawing color (0 = don't do attribute)
              	;	+3 			Bit 7 : drawn=1, erased=0
              	;	+4,5 		pointer to 16 bit pixel data, 32 bytes
              	;	+6,7 		reserved (0)
              	;
              	; ****************************************************************************************************
              	;
              	;								Draw/Erase main entry points
              	;	
              	; ****************************************************************************************************
              	
82C6:         	DrawSprite:
82C6: DDCB037E		bit 	7,(ix+3)
82CA: C0      		ret 	nz
82CB: 1807    		jr 		__DSDrawSprite
              	
82CD:         	EraseSprite:
82CD: DDCB037E		bit 	7,(ix+3)
82D1: C8      		ret 	z
82D2: 1800    		jr 		__DSDrawSprite
              	
              	; ****************************************************************************************************
              	;
              	;									Draw Sprite Main Code
              	;
              	; ****************************************************************************************************
              	
82D4:         	__DSDrawSprite:
82D4: C5      		push 	bc 								; save registers
82D5: D5      		push 	de
82D6: E5      		push 	hl
82D7: DD4600  		ld 		b,(ix+0)						; get the X position
82DA: DD4E01  		ld 		c,(ix+1) 						; get the Y position.
82DD: CD8981  		call 	CalculatePixelAndAttrAddress 	; calculate pixel/attribute address
82E0: 306A    		jr 		nc,__DSPop		 				; off screen
              	
82E2: 225183  		ld 		(__DSAttributeAddress+1),hl 	; save attribute address
82E5: ED531783		ld 		(__DSPixelAddress+1),de 		; save pixel address
              	
              	; ****************************************************************************************************
              	;						Copy address of graphic data, self modifying code.
              	; ****************************************************************************************************
              	
82E9: DD6E04  		ld 			l,(ix+4)					; graphic data
82EC: DD6605  		ld 			h,(ix+5)
82EF: 220783  		ld 			(__DSLoadGraphicData+1),hl
              	
              	; ****************************************************************************************************
              	;					Set up the pixel shifter for the 3 LSB of the x coordinate
              	; ****************************************************************************************************
              	
82F2: DD7E00  		ld 		a,(ix+0) 						; x 0-7 pixels
82F5: E607    		and 	7
82F7: 2804    		jr 		z,__DSOffsetDone 				; if zero, the JR will just fall through to register move
82F9: 3D      		dec 	a
82FA: 87      		add 	a,a	
82FB: C605    		add 	__DSShiftEntry-__DSShiftAHL-2
82FD:         	__DSOffsetDone:
82FD: 327983  		ld 		(__DSShiftAHL+1),a 				; set the JR offset.
              	
8300: CD5083  		call 	__DSColourLine 					; colour the first line.
              	
              	; ****************************************************************************************************
              	;   						   S P R I T E     M A I N     L O O P
              	; ****************************************************************************************************
              	
8303: 0610    		ld 			b,16 						; reset the draw counter to 16.
8305:         	__DSMainLoop:
8305: C5      		push 		bc
              	
              	; ****************************************************************************************************
              	;								XOR the graphic data into the screen
              	; ****************************************************************************************************
              	
8306:         	__DSLoadGraphicData:
8306: 210000  		ld 		hl,0000h 						; pointer to graphic data (modified in-line)
8309: 56      		ld 		d,(hl) 							; read into DE
830A: 23      		inc 	hl
830B: 5E      		ld 		e,(hl)
830C: 23      		inc 	hl
830D: 220783  		ld 		(__DSLoadGraphicData+1),hl 		; update graphic data pointer
              	
8310: EB      		ex 		de,hl 							; 16 bit now in HL.
8311: AF      		xor  	a 								; 24 bit graphic in AHL
              	
8312: CD7883  		call 	__DSShiftAHL					; shift it accordingly
              	
8315: EB      		ex 		de,hl 							; now it is in ADE
              	
8316:         	__DSPixelAddress:
8316: 210000  		ld 		hl,0000h						; where we will write on the screen
              	
8319: AE      		xor 	(hl) 							; XOR those three bytes in to the screen
831A: 77      		ld 		(hl),a
831B: 2C      		inc 	l
831C: 7A      		ld 		a,d
831D: AE      		xor 	(hl)
831E: 77      		ld 		(hl),a
831F: 2C      		inc 	l
8320: 7B      		ld 		a,e
8321: AE      		xor 	(hl)
8322: 77      		ld 		(hl),a
8323: 2D      		dec 	l 								; unpick the increment so HL points to the first byte
8324: 2D      		dec 	l
              	
              	; ****************************************************************************************************
              	;										Move to the next line down
              	; ****************************************************************************************************
              	
8325: CDBA81  		call 	MovePixelAddressDown 						; HL Down one line
8328: 221783  		ld 		(__DSPixelAddress+1),hl 		; update the screen address.
              	
832B: 380F    		jr 		c,__DSHNoAttributeDown 			; no attribute change
              	
832D: E5      		push 	hl 								; save HL
832E: 2A5183  		ld 		hl,(__DSAttributeAddress+1) 	; add 32 to attribute address
8331: 112000  		ld 		de,32
8334: 19      		add 	hl,de
8335: 225183  		ld 		(__DSAttributeAddress+1),hl
8338: CD5083  		call 	__DSColourLine 					; colour that line
833B: E1      		pop 	hl 								; restore HL
              	
833C:         	__DSHNoAttributeDown:
              	
833C: C1      		pop 	bc 								; restore counter
833D: 7C      		ld 		a,h
833E: FE58    		cp 		58h								; into attribute memory ?
8340: 2802    		jr 		z,__DSExitEarly 				; off bottom of screen, end of sprite draw
              	
              	
8342: 10C1    		djnz	__DSMainLoop 					; keep going till done all lines, or reached the end of screen memory
              	
8344:         	__DSExitEarly:
8344: DD7E03  		ld 		a,(ix+3)						; toggle the erased/drawn bit
8347: EE80    		xor 	080h
8349: DD7703  		ld 		(ix+3),a
              	
834C:         	__DSPop:
834C: E1      		pop 	hl
834D: D1      		pop 	de
834E: C1      		pop 	bc
834F: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;										Colour the current line
              	;
              	; ****************************************************************************************************
              	
8350:         	__DSColourLine:
              		
8350:         	__DSAttributeAddress:
8350: 210000  		ld 		hl,0000 						; address to write colour to.
8353: DD7E02  		ld 		a,(ix+2)						; get attribute to write.
8356: B7      		or 		a
8357: C8      		ret 	z
              	
8358: DDCB037E		bit 	7,(ix+3) 						; if bit 7 is set (e.g. we are erasing)
835C: 200D    		jr 		nz,__DSCLErase
              	
835E: 77      		ld 		(hl),a 							; write 2 bytes out.
835F: 23      		inc 	hl
8360: 77      		ld 		(hl),a 
8361: 47      		ld 		b,a 							; save in B.
8362: DD7E00  		ld 		a,(ix+0) 						; do not write third attribute out if X mod 8 = 0, fits in two words.
8365: E607    		and 	7
8367: C8      		ret 	z
8368: 23      		inc 	hl 								; do the third attribute byte
8369: 70      		ld 		(hl),b
836A: C9      		ret
              	
836B:         	__DSCLErase:
836B: 5D      		ld 		e,l 							; copy HL to DE
836C: 54      		ld 		d,h
836D: 7C      		ld 		a,h 							; copy from $5C00-$5EFF to $5800-$5AFF
836E: C604    		add 	4	
8370: 67      		ld 		h,a
8371: EDA0    		ldi
8373: EDA0    		ldi
8375: EDA0    		ldi
8377: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;	Shift the 24 bit value AHL left a number of times defined by the x coordinate, set up at the
              	;	start of the drawing routine.
              	;
              	; ****************************************************************************************************
              	
8378:         	__DSShiftAHL:
8378: 1805    		jr 		__DSShiftEntry 					; this jump vector is zero if x % 8 = 0, otherwise it jumps into code below to shift
837A: 7C      		ld 		a,h
837B: 65      		ld 		h,l
837C: 2E00    		ld 		l,0
837E: C9      		ret
              	
837F:         	__DSShiftEntry:
837F: 29      		add 	hl,hl 							; the JR at __DSShiftEntry jumps into this code.
8380: 8F      		adc 	a,a
8381: 29      		add 	hl,hl
8382: 8F      		adc 	a,a
8383: 29      		add 	hl,hl
8384: 8F      		adc 	a,a
8385: 29      		add 	hl,hl
8386: 8F      		adc 	a,a
              	
8387: 29      		add 	hl,hl
8388: 8F      		adc 	a,a
8389: 29      		add 	hl,hl
838A: 8F      		adc 	a,a
838B: 29      		add 	hl,hl
838C: 8F      		adc 	a,a
838D: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;								Copy attribute screen to shadow screen
              	;
              	; ****************************************************************************************************
              	
838E:         	CopyAttributeToShadow:
838E: D9      		exx
838F: 11005C  		ld 		de,05C00h 						; to shadow at $5C00
8392: 210058  		ld 		hl,05800h 						; from original at $5800
8395: 010003  		ld 		bc,32*24 						; bytes to copy
8398: EDB0    		ldir 	 								; copy.
839A: D9      		exx
839B: C9      		ret
              	
839C:         	WORD_Test:
839C: DDE5    		push 		ix
839E: FDE5    		push 		iy
83A0: CDA983  		call 		TSDraw
83A3: FDE1    		pop 		iy
83A5: DDE1    		pop 		ix
83A7: DDE9    		jp 			(ix)
              	
              	
              	; ****************************************************************************************************
              	
83A9:         	TSDraw:
83A9: CD8E83  		call 	CopyAttributeToShadow
83AC: DD21F083		ld 		ix,testSprite
83B0: 21F401  		ld 		hl,1000/2
83B3:         	TSLoop:
83B3: E5      		push 	hl
83B4: CDC682  		call 	DrawSprite
83B7: CDCD82  		call 	EraseSprite
83BA: DD7E00  		ld 		a,(ix+0)
83BD: EE20    		xor 	32
83BF: DD7700  		ld 		(ix+0),a
              	
83C2: DD7E02  		ld 		a,(ix+2)
83C5: EE04    		xor 	4
83C7: DD7702  		ld 		(ix+2),a
83CA: E1      		pop 	hl
83CB: 2B      		dec 	hl
83CC: 7C      		ld 		a,h
83CD: B5      		or 		l
83CE: 20E3    		jr 		nz,TSLoop
83D0: C9      		ret
              	
83D1:         	TSDelay:
83D1: 21E803  		ld 		hl,1000
83D4:         	TSDelay1:
83D4: 2B      		dec 	hl
83D5: 7C      		ld 		a,h
83D6: B5      		or 		l
83D7: 20FB    		jr 		nz,TSDelay1
83D9: DD3400  		inc 	(ix+0)
83DC: DD3401  		inc 	(ix+1)
83DF: DD7E01  		ld 		a,(ix+1)
83E2: FEA0    		cp 		160
83E4: 20CD    		jr 		nz,TSLoop
83E6: DD360045		ld 		(ix+0),69
83EA: DD360121		ld 		(ix+1),33
83EE: 18C3    		jr 		TSLoop
              	
83F0:         	testSprite:
83F0: 43      		defb 	67
83F1: 23      		defb 	35		
83F2: 4500    		defb 	045h,0
83F4: F8830000		defw 	graphicData,0
              	
83F8:         	graphicData:
83F8: FFFF    		defb 	0FFh,0FFh
83FA: AAAA    		defb 	0AAh,0AAh
83FC: 8003    		defb 	080h,003h
83FE: 8007    		defb 	080h,007h
              	
8400: 8F0F    		defb 	08Fh,00Fh
8402: 801F    		defb 	080h,01Fh
8404: FFE0    		defb 	0FFh,0E0h
8406: 0200    		defb 	002h,000h
              	
8408: 0200    		defb 	002h,000h
840A: 0700    		defb 	007h,000h
840C: 8001    		defb 	080h,001h
840E: 8001    		defb 	080h,001h
              	
8410: 8001    		defb 	080h,001h
8412: 8001    		defb 	080h,001h
8414: 8001    		defb 	080h,001h
8416: FFFF    		defb 	0FFh,0FFh
              	
              	
8418:         	BootWord:
8418: FDE9    		jp 			(iy)
841A: 0082    		defw 		WORD_ClearScreen
841C: 2484    		defw 		WORD_Star
841E: 9C83    		defw 		WORD_Test
8420: 2484    		defw 		WORD_Star
8422: 7181    		defw 		WORD_Stop
              	
8424:         	WORD_Star:
8424: FDE9    		jp 			(iy)
8426: 2980    		defw 		Core_Literal
8428: 2A00    		defw 		42
842A: CE81    		defw 		WORD_Emit
842C: 3180    		defw 		Core_Return
              	
842E:         	EndOfCode:
              	
              	; ****************************************************************************************************
              	;
              	;												Examples
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	Code word (example) DUP. Note that in code words DE is the code pointer.
              	;	We just go straight in with the machine code. Code words can only use HL as a temporary value
              	; 	so for things like + use EXX and do it in the alternate set.
              	;
              	;
              	;dup:										; <<dup>>
              	;	pop 	hl
              	;	push 	hl
              	;	push 	hl
              	;	jp		(ix)							; and fix up so HL is the code pointer again and loop
              	;
              	;
              	;
              	;	Word built up out of other definitions.
              	;	
              	;	jp 		(iy)							; identifies as a word from words.
              	;
              	;	; first def addr
              	;	; second def addr
              	;	;	..
              	;	;	..
              	;
              	;	defw 	Core_Return 					; now we want to go back.
              	;
              	
              	
              	


total time: 0.0026 sec.
no errors
