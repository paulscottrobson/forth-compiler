              	; --------------------------------------
              	; zasm: assemble "forth.asm"
              	; date: 2017-05-16 11:29:12
              	; --------------------------------------


              	; ****************************************************************************************************
              	;
              	;									Forth Compiler Runtime
              	;
              	; ****************************************************************************************************
              	
              		include 	"sna_header.asm"			; .SNA boot header
              	; *****************************************************************************************
              	; *****************************************************************************************
              	;
              	;                       SNA Header - variant of the provided example.
              	;
              	; *****************************************************************************************
              	; *****************************************************************************************
              	
              	#target sna
              	
              	; *****************************************************************************************
              	;
              	;                               saved registers, restored in NMI
              	;
              	; *****************************************************************************************
              	
0000:         	#code HEAD, 0, 27
0000: 3F      	    defb    $3f             ; i
0001: 0000    	    defw    0               ; hl'
0003: 0000    	    defw    0               ; de'
0005: 0000    	    defw    0               ; bc'
0007: 0000    	    defw    0               ; af'
              	
0009: 0000    	    defw    0               ; hl
000B: 0000    	    defw    0               ; de
000D: 0000    	    defw    0               ; bc
000F: 0000    	    defw    0               ; iy
0011: 0000    	    defw    0               ; ix
              	
0013: 00      	    defb    0<<2            ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei
0014: 000000  	    defb    0,0,0           ; r,f,a
0017: 035B    	    defw    __stackEnd      ; sp
0019: 01      	    defb    1               ; irpt mode
001A: 00      	    defb    0               ; border color: 0=black ... 7=white
              	
              	; *****************************************************************************************
              	;
              	;                   $4000-$7FFF. Pixel Memory, Attribute Memory, Slow RAM
              	;
              	; *****************************************************************************************
              	
4000:         	#code SLOW_RAM, 0x4000, 0x4000
              	
4000:         	VideoMemory:
4000: 00000000	    defs    0x1800
4004: 00...   	
5800:         	AttributeMemory:
5800: 00000000	    defs    0x300
5804: 00...   	
5B00:         	EndVideoMemory:
              	
5B00:         	__bootSNA:
5B00: C30480  	    jp      start
              	
              	; *****************************************************************************************
              	;
              	;                            $8000-$FFFF. Non contentious memory
              	;
              	; *****************************************************************************************
              	
5B03:         	__stackEnd:   
5B03: 005B    	    defw    __bootSNA
              	
8000:         	#code FAST_RAM, 0x8000, 0x8000
              	
              		include 	"core4.asm" 				; Forth core (Direct Threaded)
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;													Core v4
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;	These words are accessed/changed by the compiler, so it knows (i) where to start the program
              	;	and (ii) where it can compile code.
              	;
              	; ****************************************************************************************************
              	
8000:         	BootAddress:
8000: DC83    		defw 	BootWord 						; start of threaded word.
8002:         	FreeAddress:
8002: F283    		defw 	EndOfCode 						; end of code that is built with the assembler.
              	
              	; ****************************************************************************************************
              	;
              	;										Start Forth Core
              	;
              	; ****************************************************************************************************
              		
8004:         	start:
8004: DD212280		ld 		ix,Core_Continue  				; these allow us to do fast jumps in and out of routines.
8008: FD211980		ld 		iy,Core_Call 					; also saving a byte on long jumps.
              	
800C: 310000  		ld 		sp,0x0000 						; sp is the data stack (works down)
800F: 0100FF  		ld 		bc,0xFF00 						; bc is the return stack (works up)
              	
8012: 2A0080  		ld 		hl,(BootAddress)				; hl is the IP (except when executing Z80 code words)
8015: 23      		inc 	hl 								; skip over the JP (IY)
8016: 23      		inc 	hl
8017: 180A    		jr 		Core_Execute
              	
              	; ****************************************************************************************************
              	;
              	;		The JP (IY) at the start of a threaded definition comes here. DE contains
              	; 		the old address, HL the new one.
              	;
              	;		Save the calling address on the stack and execute from HL. Which handily is in HL.
              	;
              	; ****************************************************************************************************
              	
8019:         	Core_Call:
8019: 23      		inc 	hl 								; advance HL over the JP(IY) $FD $E9
801A: 23      		inc 	hl 								; now points to the first definition
              	
801B: 7B      		ld 		a,e 							; push DE (old address) on the BC stack.
801C: 03      		inc 	bc 								; unfortunately a Z80 only has one stack, so we have
801D: 02      		ld 		(bc),a 							; to use it for either data *or* return.
801E: 7A      		ld 		a,d
801F: 03      		inc 	bc
8020: 02      		ld 		(bc),a
              	
8021: EB      		ex 		de,hl 							; allows us to fall through to execute loop
              	
              	; ****************************************************************************************************
              	;
              	;	Ending a machine code definition comes here (using JP (IX)). We need this exchange
              	; 	because when running m/c definition DE is the instruction pointer
              	;
              	; ****************************************************************************************************
              	
8022:         	Core_Continue:
8022: EB      		ex 		de,hl 							; if executing code word come back here.
              	
              	; ****************************************************************************************************
              	;
              	;					Main execution entry point. Execute instruction at (DE)
              	;
              	; ****************************************************************************************************
              	
8023:         	Core_Execute:
8023: 5E      		ld 		e,(hl)							; read address of next word at HL into DE, LSB first
8024: 23      		inc 	hl
8025: 56      		ld 		d,(hl)
8026: 23      		inc 	hl
8027: EB      		ex 		de,hl 							; swap so when executing code word DE code ptr and so we can 
8028: E9      		jp 		(hl) 							; do this 4 cycle jump
              	
              	; ****************************************************************************************************
              	;
              	;											16 bit literal word
              	;
              	; ****************************************************************************************************
              	
8029:         	Core_Literal:								; <<.literal>>
8029: EB      		ex 		de,hl 							; HL now contains the IP back again.
802A: 5E      		ld 		e,(hl) 							; load next word into DE
802B: 23      		inc 	hl
802C: 56      		ld 		d,(hl)
802D: 23      		inc 	hl
802E: D5      		push 	de 								; push word on data stack
802F: 18F2    		jr 		Core_Execute 					; and execute without doing the DE/HL swap
              	
              	; ****************************************************************************************************
              	;
              	;												Return word.
              	;
              	; ****************************************************************************************************
              	
8031:         	Core_Return:								; <<;>>
8031: 0A      		ld 		a,(bc) 							; pop address into DE.
8032: 0B      		dec 	bc
8033: 57      		ld 		d,a 
8034: 0A      		ld 		a,(bc)
8035: 0B      		dec 	bc
8036: 5F      		ld 		e,a
8037: DDE9    		jp 		(ix) 							; this will put DE -> HL and start executing one level up.
              	
              		include 	"library.asm" 				; Basic FORTH words including optional text/sprite stuff
              	; ****************************************************************************************************
              	;
              	;								 Basic FORTH Library, Z80 Assembler
              	;
              	; ****************************************************************************************************
              	
              		include "library/binary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Binary)
              	;
              	; ****************************************************************************************************
              	
8039:         	WORD_Add:									; <<+>>
8039: D9      		exx 
803A: E1      		pop		hl
803B: D1      		pop 	de
803C: 19      		add 	hl,de
803D: E5      		push 	hl
803E: D9      		exx
803F: DDE9    		jp 		(ix)
              	
8041:         	WORD_Subtract: 								; <<->>
8041: D9      		exx 
8042: D1      		pop 	de
8043: E1      		pop 	hl
8044: AF      		xor 	a
8045: ED52    		sbc 	hl,de
8047: E5      		push 	hl
8048: D9      		exx 	
8049: DDE9    		jp 		(ix)
              	
804B:         	WORD_And:									; <<and>>
804B: D9      		exx
804C: D1      		pop 	de
804D: E1      		pop 	hl
804E: 7C      		ld 		a,h 							; do MSB
804F: A2      		and 	d
8050: 67      		ld 		h,a
8051: 7D      		ld 		a,l 							; do LSB
8052: A3      		and 	e
8053:         	__WORD_Logic_Exit:
8053: 6F      		ld 		l,a 							
8054: E5      		push 	hl
8055: D9      		exx
8056: DDE9    		jp 		(ix)
              	
8058:         	WORD_Xor:									; <<xor>>
8058: D9      		exx
8059: D1      		pop 	de
805A: E1      		pop 	hl
805B: 7C      		ld 		a,h 							; do MSB
805C: AA      		xor 	d
805D: 67      		ld 		h,a
805E: 7D      		ld 		a,l 							; do LSB
805F: AB      		xor 	e
8060: 18F1    		jr 		__WORD_Logic_Exit
              	
8062:         	WORD_Or:									; <<or>>
8062: D9      		exx
8063: D1      		pop 	de
8064: E1      		pop 	hl
8065: 7C      		ld 		a,h 							; do MSB
8066: B2      		or 		d
8067: 67      		ld 		h,a
8068: 7D      		ld 		a,l 							; do LSB
8069: B3      		or 		e
806A: 18E7    		jr 		__WORD_Logic_Exit
              	
              		include "library/unary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Unary)
              	;
              	; ****************************************************************************************************
              	
              	; abs sgn
              	
806C:         	WORD_0Minus:								; <<0->>
806C: D9      		exx
806D: D1      		pop 	de
806E: 210000  		ld 		hl,0
8071: AF      		xor 	a
8072: ED52    		sbc 	hl,de
8074: E5      		push 	hl
8075: D9      		exx 	
8076: DDE9    		jp 		(ix)
              	
8078:         	WORD_0Equals:
8078: E1      		pop 	hl 								; <<0=>>
8079: 7C      		ld 		a,h
807A: B5      		or 		l
807B: 2806    		jr 		z,__UNPushTrue
807D:         	__UNPushFalse:
807D: 210000  		ld 		hl,0
8080: E5      		push 	hl
8081: DDE9    		jp 		(ix)
8083:         	__UNPushTrue:
8083: 21FFFF  		ld 		hl,0xFFFF
8086:         	__UNPushHLExit	
8086: E5      		push 	hl
8087: DDE9    		jp		(ix)
              	
8089:         	WORD_0LessThan:								; <<0<>>
8089: E1      		pop 	hl
808A: CB7C    		bit 	7,h
808C: 20F5    		jr 		nz,__UNPushTrue
808E: 18ED    		jr 		__UNPushFalse
              	
8090:         	WORD_Abs:									; <<abs>>
8090: E1      		pop 	hl
8091: CB7C    		bit 	7,h 							
8093: 28F1    		jr 		z,__UNPushHLExit 				; if zero push unchanged
8095: E5      		push 	hl
8096: 18D4    		jr	 	WORD_0Minus 					; otherwise do 0-
              	
8098:         	WORD_Sgn:									; <<sgn>>
8098: E1      		pop 	hl
8099: CB7C    		bit 	7,h 							; -ve
809B: 20E6    		jr 		nz,__UNPushTrue
809D: 7C      		ld 		a,h 							; zero
809E: B5      		or 		l
809F: 28DC    		jr 		z,__UNPushFalse
80A1: 210100  		ld 		hl,1 							; +ve push 1
80A4: 18E0    		jr 		__UNPushHLExit
              		
              	; ****************************************************************************************************
              	;
              	;										Arithmetic Quickies
              	;
              	; ****************************************************************************************************
              	
80A6:         	WORD_OnePlus:
80A6: E1      		pop		hl								; <<1+>>
80A7: 1802    		jr 		__OnePlus
              	
80A9:         	WORD_TwoPlus:
80A9: E1      		pop		hl								; <<2+>>
80AA: 23      		inc 	hl
80AB:         	__OnePlus:	
80AB: 23      		inc 	hl
80AC: E5      		push 	hl
80AD: DDE9    		jp 		(ix)
              	
80AF: E1      		pop		hl								; <<1->>
80B0: 1802    		jr 		__OneMinus
              	
80B2: E1      		pop		hl								; <<1->>
80B3: 2B      		dec 	hl
80B4:         	__OneMinus:	
80B4: 2B      		dec 	hl
80B5: E5      		push 	hl
80B6: DDE9    		jp 		(ix)
              	
80B8: E1      		pop		hl 								; <<2*>>
80B9: 1807    		jr 		__TwoTimes
              	
80BB: E1      		pop 	hl								; <<4*>>
80BC: 1803    		jr 		__FourTimes
              	
80BE: E1      		pop		hl 								; <<16*>>
80BF: 29      		add 	hl,hl
80C0: 29      		add 	hl,hl
80C1:         	__FourTimes:
80C1: 29      		add 	hl,hl
80C2:         	__TwoTimes:	
80C2: 29      		add 	hl,hl
80C3: E5      		push 	hl
80C4: DDE9    		jp 		(ix)
              	
80C6: E1      		pop 	hl 								; <<256*>
80C7: 65      		ld	 	h,l
80C8: 2E00    		ld	 	l,0
80CA: E5      		push 	hl
80CB: DDE9    		jp 		(ix)
              	
80CD: E1      		pop 	hl 								; <<2/>>
80CE: 180D    		jr 		__TwoDivide	
              	
80D0: E1      		pop 	hl 								; <<16/>>
              	
80D1: CB2C    		sra 	h
80D3: CB1D    		rr 		l
80D5: CB2C    		sra 	h
80D7: CB1D    		rr 		l
80D9: CB2C    		sra 	h
80DB: CB1D    		rr 		l
              	
80DD:         	__TwoDivide:
80DD: CB2C    		sra 	h
80DF: CB1D    		rr 		l
80E1: E5      		push 	hl
80E2: DDE9    		jp 		(ix)
              	
80E4: E1      		pop 	hl								; <<256/>>
80E5: 6C      		ld	 	l,h
80E6: 2600    		ld 	 	h,0
80E8: CB7D    		bit 	7,l 							; sign extend
80EA: 2801    		jr 		z,__ByteDivideNotSigned
80EC: 25      		dec 	h
80ED:         	__ByteDivideNotSigned: 	
80ED: E5      		push 	hl
80EE: DDE9    		jp 		(ix)
              		include "library/constants.asm"
              	; ****************************************************************************************************
              	;
              	;						Constants, quicker and shorter versions of .literal
              	;
              	; ****************************************************************************************************
              	
              	ConstantWord macro value
              		ld 		hl,&value 						; <<&value>>
              		push 	hl
              		jp 		(ix)
              		endm
              	;
              	;	If you use these (which the compiler does automatically) it saves two bytes over .literal [n]
              	;	and also is several cycles quicker, because it doesn't fetch the value. A similar system is
              	;	used for variables/arrays/constants as these are all 6 bytes long (same as .literal [n] return)
              	;
              		ConstantWord 	-1
80F0: 21FFFF  		ld 		hl,-1 						; <<-1>>
80F3: E5      		push 	hl
80F4: DDE9    		jp 		(ix)
              		ConstantWord 	0	
80F6: 210000  		ld 		hl,0 						; <<0>>
80F9: E5      		push 	hl
80FA: DDE9    		jp 		(ix)
              		ConstantWord 	1
80FC: 210100  		ld 		hl,1 						; <<1>>
80FF: E5      		push 	hl
8100: DDE9    		jp 		(ix)
              		ConstantWord 	2
8102: 210200  		ld 		hl,2 						; <<2>>
8105: E5      		push 	hl
8106: DDE9    		jp 		(ix)
              		ConstantWord 	4
8108: 210400  		ld 		hl,4 						; <<4>>
810B: E5      		push 	hl
810C: DDE9    		jp 		(ix)
              		ConstantWord 	8
810E: 210800  		ld 		hl,8 						; <<8>>
8111: E5      		push 	hl
8112: DDE9    		jp 		(ix)
              		ConstantWord 	10
8114: 210A00  		ld 		hl,10 						; <<10>>
8117: E5      		push 	hl
8118: DDE9    		jp 		(ix)
              		ConstantWord 	16
811A: 211000  		ld 		hl,16 						; <<16>>
811D: E5      		push 	hl
811E: DDE9    		jp 		(ix)
              		ConstantWord 	100
8120: 216400  		ld 		hl,100 						; <<100>>
8123: E5      		push 	hl
8124: DDE9    		jp 		(ix)
              		ConstantWord 	256
8126: 210001  		ld 		hl,256 						; <<256>>
8129: E5      		push 	hl
812A: DDE9    		jp 		(ix)
              	
              		include "library/stack.asm"
              	; ****************************************************************************************************
              	;
              	;										  Stack Manipulation
              	;
              	; ****************************************************************************************************
              	
812C:         	WORD_Dup:									; <<dup>>
812C: E1      		pop 	hl 								; get TOS and push it back twice
812D: E5      		push 	hl
812E: E5      		push 	hl
812F: DDE9    		jp 		(ix) 							; return 
              	
8131:         	WORD_Drop:									; <<drop>>
8131: E1      		pop 	hl
8132: DDE9    		jp 		(ix)
              	
8134:         	WORD_Swap:									; <<swap>>
8134: D9      		exx 									; use alt register set
8135: E1      		pop 	hl 								; get TOS and push it back twice
8136: D1      		pop 	de
8137: E5      		push 	hl
8138: D5      		push 	de
8139: D9      		exx 
813A: DDE9    		jp 		(ix) 							; return 
              	
813C:         	WORD_Over:									; <<over>>
813C: D9      		exx 						
813D: E1      		pop 	hl 								; tos
813E: D1      		pop 	de 								; tos 2
813F: D5      		push 	de 								; push back
8140: E5      		push 	hl
8141: D5      		push 	de 								; with tos 2 on top
8142: D9      		exx
8143: DDE9    		jp 		(ix)
              	
8145:         	WORD_Rot:									; <<rot>>
8145: D9      		exx
8146: E1      		pop 	hl 								; X3  X1 X2 X3 -> X2 X3 X1
8147: D1      		pop 	de 								; X2 
8148: C1      		pop		bc 								; X1
8149: D5      		push 	de
814A: E5      		push 	hl
814B: C5      		push 	bc
814C: D9      		exx
814D: DDE9    		jp 		(ix)
              	
814F:         	WORD_Pick:									; <<pick>>
814F: D9      		exx 		
8150: E1      		pop 	hl 								; get the index off the stack
8151: 39      		add 	hl,sp 							; add stack offset
8152: 56      		ld 		d,(hl) 							; read stack value
8153: 23      		inc 	hl
8154: 5E      		ld 		e,(hl)
8155: D5      		push 	de 								; push on the stack
8156: D9      		exx
8157: DDE9    		jp 		(ix)
              		include "library/misc.asm"
              	; ****************************************************************************************************
              	;
              	; 												Miscellany
              	;
              	; ****************************************************************************************************
              	
              	
8159:         	WORD_Branch:								; <<[br]>>
8159: EB      		ex 	 	de,hl 							; HL now points to the next word
815A: 5E      		ld 		e,(hl)							; read into DE
815B: 23      		inc 	hl
815C: 56      		ld 		d,(hl)
815D: DDE9    		jp 		(ix) 							; and go there.
              	
815F:         	WORD_BranchZero:
815F: E1      		pop 	hl 								; non destructive test of TOS
8160: E5      		push 	hl
8161: 7C      		ld 		a,h 							; branch if zero.
8162: B5      		or 		l
8163: 28F4    		jr 		z,WORD_Branch
8165:         	__WORD_BranchFail:							; if non zero
8165: 13      		inc 	de 								; skip over jump address
8166: 13      		inc 	de
8167: DDE9    		jp 		(ix)
              	
8169:         	WORD_BranchPositive:
8169: E1      		pop 	hl 								; non destructive test of TOS
816A: E5      		push 	hl
816B: CB7C    		bit 	7,h 							; if +ve branch
816D: 28EA    		jr 		z,WORD_Branch
816F: 18F4    		jr 		__WORD_BranchFail 				; if -ve don't
              	
8171:         	WORD_Stop:									; <<stop>>
8171: 18FE    		jr 		WORD_Stop
              	
8173:         	WORD_RStoDS:								; <<r>>>
8173: 0A      		ld 		a,(bc) 							; pop address into HL
8174: 0B      		dec 	bc
8175: 67      		ld 		h,a 
8176: 0A      		ld 		a,(bc)
8177: 0B      		dec 	bc
8178: 6F      		ld 		l,a
8179: E5      		push 	hl 								; push on data stack.
817A: DDE9    		jp 		(ix)
              	
817C:         	WORD_DStoRS:								; <<>r>>
817C: E1      		pop 	hl 								; get top of data stack
817D: 03      		inc 	bc 								; push on return stack.
817E: 7D      		ld 		a,l
817F: 02      		ld 		(bc),a
8180: 03      		inc 	bc
8181: 7C      		ld 		a,h
8182: 02      		ld 		(bc),a
8183: DDE9    		jp 		(ix)
              	
8185:         	WORD_RDrop:									; <<rdrop>>
8185: 0B      		dec 	bc
8186: 0B      		dec 	bc
8187: DDE9    		jp 		(ix)
              		include "library/io.asm"
              	; ****************************************************************************************************
              	;
              	;										Input/Output functions
              	;
              	; ****************************************************************************************************
              	
8189:         	WORD_Emit:									; <<emit>>
8189: E1      		pop 	hl 								; get character to print in L
818A: CDCD81  		call	PrintCharL
818D: DDE9    		jp 		(ix)
              	
818F:         	WORD_PrintInteger:							; <<.>>
818F: E1      		pop 	hl
8190: CD2B82  		call 	PrintInteger
8193: DDE9    		jp 		(ix)
              	
8195:         	WORD_PrintStack:							; <<.stack>>
8195: D5      		push 	de 								; save DE
8196: 210000  		ld 		hl,0  							; get SP into HL
8199: 23      		inc 	hl 								; skip over PUSH DE above
819A: 23      		inc 	hl
819B: 39      		add 	hl,sp
819C: 3E46    		ld  	a,46h 							; first yellow
819E: 328082  		ld 		(__PCAColour),a
81A1:         	__PSLoop:
81A1: 5E      		ld 		e,(hl) 							; load into DE
81A2: 23      		inc 	hl
81A3: 56      		ld 		d,(hl)
81A4: 23      		inc 	hl
81A5: EB      		ex 		de,hl 							; print it
81A6: CD2B82  		call 	PrintInteger
81A9: EB      		ex 		de,hl
81AA: 3E44    		ld  	a,44h 							; remainder green
81AC: 328082  		ld 		(__PCAColour),a
81AF: 7C      		ld 		a,h 							; reached top of stack
81B0: B7      		or 		a
81B1: 20EE    		jr 		nz,__PSLoop
81B3: D1      		pop 	de 								; restore DE
81B4: 2E0D    		ld 		l,13 							; print CR
81B6: CDCD81  		call 	PrintCharL
81B9: DDE9    		jp 		(ix)
              	
81BB:         	WORD_ClearScreen:							; <<cls>>
81BB: CD5282  		call 	ClearScreen
81BE: CD6C82  		call 	HomeCursor
81C1: DDE9    		jp 		(ix)
              	
81C3:         	WORD_CR:									; <<cr>>
81C3: FDE9    		jp 		(iy)
81C5: 2980    		defw 	Core_Literal
81C7: 0D00    		defw 	13
81C9: 8981    		defw 	WORD_Emit
81CB: 3180    		defw 	Core_Return
              	
              	; ****************************************************************************************************
              	;			This is included if io.asm is included, provides direct I/O to Speccy hardware
              	; ****************************************************************************************************
              	
              		include "utils/screen.asm" 				; Screen I/O routines.
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;			Replacement for Spectrums Screen Display Routine, straight 32x24 video display
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;							Print character in L ; all registers preserved.
              	;
              	; ****************************************************************************************************
              	
81CD:         	PrintCharL:
81CD: F5      		push 	af 								; stack registers
81CE: C5      		push 	bc 								
81CF: D5      		push 	de
81D0: E5      		push 	hl
              	
81D1: 7D      		ld 		a,l 							; check for CR ?
81D2: FE0D    		cp 		13
81D4: 2847    		jr		z,__PCLReturn
              	
81D6: 0600    		ld 		b,0 							; B is the reversing byte
81D8: CB7D    		bit 	7,l 							; if bit 7 set
81DA: 2803    		jr 		z,__PCANotReverse
81DC: 05      		dec 	b 								; B becomes $FF
81DD: CBBD    		res 	7,l 							; drop bit 7
81DF:         	__PCANotReverse:
81DF: 2600    		ld 		h,0 							; HL to 16 bit
81E1: ED5B7A82		ld 		de,(__PCAFont)					; DE = Font Base
81E5: 29      		add 	hl,hl 							; calc Font Base + char * 8
81E6: 29      		add 	hl,hl
81E7: 29      		add 	hl,hl
81E8: 19      		add 	hl,de
81E9: EB      		ex 		de,hl 							; put in DE
81EA: 2A7C82  		ld 		hl,(__PCAVideoPos) 				; get write address
81ED: E5      		push 	hl 								; save for later
81EE:         	_PCALoop:	
81EE: 1A      		ld 		a,(de) 							; read font char
81EF: A8      		xor 	b 								; reverse byte
81F0: 77      		ld 		(hl),a 							; write to screen
81F1: 1C      		inc 	e 								; bump pointers
81F2: 24      		inc 	h
81F3: 7C      		ld 		a,h 							; until done whole row
81F4: E607    		and 	7
81F6: 20F6    		jr 		nz,_PCALoop
              	
              	
81F8: ED5B7E82		ld 		de,(__PCAAttribPos)				; copy colour byte to attribute memory.
81FC: 3A8082  		ld 		a,(__PCAColour)
81FF: 12      		ld 		(de),a
8200: 13      		inc 	de
              	
8201: E1      		pop 	hl 								; restore original video position to HL
8202: 2C      		inc 	l 								; right one
8203: 200C    		jr 		nz,__PCANotNewPage 				; if nz don't need new 1/4k page
8205: 7C      		ld 		a,h 							; advance to next quarter page
8206: C608    		add 	8
8208: 67      		ld 		h,a 	
8209: FE58    		cp 		0x58 							; we only have 3, this is the attribute page
820B: 2004    		jr 		nz,__PCANotNewPage
820D: 2640    		ld 		h,0x40 							; wrap round to top.
820F: 1658    		ld 		d,0x58 							; reset attribute memory pointer
8211:         	__PCANotNewPage:
8211: 227C82  		ld 		(__PCAVideoPos),hl 				; update new position in video / attr
8214: ED537E82		ld 		(__PCAAttribPos),de 			
              	
8218:         	__PCLExit:
8218: E1      		pop 	hl 								; destack.
8219: D1      		pop 	de
821A: C1      		pop 	bc
821B: F1      		pop 	af
821C: C9      		ret
              	
821D:         	__PCLReturn: 								; carriage return.
821D: 2E20    		ld 		l,' '
821F: CDCD81  		call 	PrintCharL
8222: 3A7C82  		ld 		a,(__PCAVideoPos)
8225: E61F    		and 	31
8227: 20F4    		jr 		nz,__PCLReturn
8229: 18ED    		jr 		__PCLExit
              	
              	; ****************************************************************************************************
              	;
              	;									Print HL in hexadecimal
              	;
              	; ****************************************************************************************************
              	
822B:         	PrintInteger:
822B: E5      		push 	hl
822C: 2E20    		ld 		l,' ' 							; print leading space
822E: CDCD81  		call 	PrintCharL
8231: E1      		pop 	hl
8232: 7C      		ld 		a,h
8233: CD3B82  		call 	PrintByteA
8236: 7D      		ld 		a,l
8237: CD3B82  		call 	PrintByteA
823A: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;									Print Byte in Hexadecimal
              	;
              	; ****************************************************************************************************
              	
823B:         	PrintByteA:
823B: F5      		push 	af 								; save A on stack
823C: 1F      		rra 									; shift right 4
823D: 1F      		rra
823E: 1F      		rra
823F: 1F      		rra
8240: CD4482  		call	__PBANibble 					; print it
8243: F1      		pop 	af 								; restore
8244:         	__PBANibble:
8244: F6F0    		or 		0F0h 							; DAA trick
8246: 27      		daa
8247: C6A0    		add 	a,0A0h
8249: CE40    		adc 	a,040h
824B: E5      		push 	hl 								; print character
824C: 6F      		ld 		l,a
824D: CDCD81  		call 	PrintCharL
8250: E1      		pop 	hl
8251: C9      		ret
              	
              	; ****************************************************************************************************
              	;	
              	;											Clear Screen
              	;
              	; ****************************************************************************************************
              	
8252:         	ClearScreen:
8252: E5      		push 	hl
8253: 210040  		ld 		hl,0x4000 						; fill 4000-57FF with zero
8256:         	__CLSLoop1:
8256: 3600    		ld 		(hl),0
8258: 23      		inc 	hl
8259: 7C      		ld 		a,h
825A: FE58    		cp 		0x58
825C: 20F8    		jr		nz,__CLSLoop1
825E:         	__CLSLoop2:									; fill 5800-5FFF with 7 (white)
825E: 3607    		ld 		(hl),7
8260: 23      		inc 	hl
8261: 7C      		ld 		a,h
8262: FE5B    		cp 		0x5B
8264: 20F8    		jr		nz,__CLSLoop2
8266: 3E01    		ld 		a,1 							; set border to blue.
8268: D3FE    		out 	(0xFE),a
826A: E1      		pop 	hl
826B: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Home Cursor
              	;
              	; ****************************************************************************************************
              	
826C:         	HomeCursor:	
826C: E5      		push 	hl
826D: 210058  		ld 		hl,0x5800 						; reset attribute pos
8270: 227E82  		ld 		(__PCAAttribPos),hl
8273: 2640    		ld 		h,0x40 							; reset video pos
8275: 227C82  		ld 		(__PCAVideoPos),hl
8278: E1      		pop 	hl
8279: C9      		ret
              	
827A:         	__PCAFont: 									; font base here
827A: 003C    		defw 	0x3C00
827C:         	__PCAVideoPos: 								; current video memory pointer.
827C: 0040    		defw 	VideoMemory
827E:         	__PCAAttribPos:								; current attribute pointer
827E: 0058    		defw 	AttributeMemory
8280:         	__PCAColour: 								; current colour to use
8280: 44      		defb 	0x44
              		include "library/sprites.asm"
              	; ****************************************************************************************************
              	;
              	;										16 x 16 Sprite Words
              	;
              	; ****************************************************************************************************
              	
8281:         	WORD_Test:
8281: C5      		push 		bc
8282: D5      		push 		de
8283: DDE5    		push 		ix
8285: CD8883  		call 		TSDraw
8288: DDE1    		pop 		ix
828A: D1      		pop 		de
828B: C1      		pop			bc
828C: DDE9    		jp 			(ix)
              	
              		include 	"utils/sprites16x16.asm"
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;										16 x 16 Sprite Routines
              	;
              	;	These sprites are simple 16x16 XOR which restore the background attributes from a shadow of 
              	;	$5800-$5B00 at $5C00-$5F00. It is designed to operate not dissimilarly to the Next ; pure 
              	; 	XOR sprites can be removed and moved in any order you like.
              	;
              	;	There is some self modifying code here - the pointers are all kept in SMC, so is the counter
              	;	and it is also used to modify the 24 bit shifter.
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;	
              	;	IX points to the sprite data, as follows.
              	;
              	;	+0 			X position (0-255)
              	;	+1 			Y position (0-191)
              	;	+2 			Drawing color (0 = don't do attribute)
              	;	+3 			Bit 7 : drawn=1, erased=0
              	;	+4,5 		pointer to 16 bit pixel data, 32 bytes
              	;	+6,7 		reserved (0)
              	;
              	
              	
              	; ****************************************************************************************************
              	;
              	;								Copy attribute screen to shadow screen
              	;
              	; ****************************************************************************************************
              	
828E:         	CopyAttributeToShadow:
828E: 11005C  		ld 		de,05C00h
8291: 210058  		ld 		hl,05800h
8294: 010003  		ld 		bc,32*24
8297: EDB0    		ldir 	
8299: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Draw Sprite
              	;
              	; ****************************************************************************************************
              	
              	
829A:         	__DSDrawSprite:
829A: DD7E01  		ld 		a,(ix+1) 						; get the Y position.
829D: FEC0    		cp 		192
829F: D0      		ret 	nc 								; if >= 24*8 then exit now.	
              	
82A0: 5F      		ld  	e, a 							; save in E
82A1: E607    		and 	7 								; get the three low bits.
82A3: 67      		ld  	h,a 							; goes in H bits 2..0
              	
82A4: 7B      		ld 		a,e 							; we want bits 7..6 to be in 4..3
82A5: 1F      		rra 									; in 6..5
82A6: 1F      		rra 									; in 5..4
82A7: 1F      		rra										; in 4..3
              	
82A8: E618    		and 	018h 							; isolate
82AA: B4      		or 		h 								; or with H
82AB: F640    		or 		040h 							; set bit 6
82AD: 67      		ld 		h,a 							; and copy back.
              	
82AE: 7B      		ld 		a,e 							; we want bits 5,4,3 to be in slots 7,6,5
82AF: 87      		add 	a,a
82B0: 87      		add 	a,a
82B1: E6E0    		and 	0E0h
82B3: 6F      		ld 		l,a 							; save in L
              	
82B4: DD7E00  		ld 		a,(ix+0) 						; get X bits 7..3 - 4..0
82B7: 1F      		rra
82B8: 1F      		rra
82B9: 1F      		rra	
82BA: E61F    		and 	1Fh
82BC: 4F      		ld 		c,a 							; save X/8 in C
              	
82BD: B5      		or  	l 								; or into L and write back
82BE: 6F      		ld  	l,a 							; HL now is the base graphic
82BF: 220083  		ld 		(__DSLoadScreenAddress+1),hl 	; save it out
              	
82C2: DD7E01  		ld 		a,(ix+1) 						; get Y
82C5: E6F8    		and 	0F8h							; now (Y / 8) * 8
82C7: 6F      		ld 		l,a
82C8: 2600    		ld 		h,0
82CA: 29      		add 	hl,hl 						
82CB: 29      		add 	hl,hl 							; now (Y / 8) * 32
              	
82CC: 0658    		ld 		b,058h 							; B = $5800 + (X / 8)
82CE: 09      		add 	hl,bc
82CF: 223783  		ld 		(__DSAttributeAddress+1),hl 	; save attribute address
              	
              	; ****************************************************************************************************
              	;						Copy address of graphic data, self modifying code.
              	; ****************************************************************************************************
              	
82D2: DD6E04  		ld 			l,(ix+4)					; graphic data
82D5: DD6605  		ld 			h,(ix+5)
82D8: 22F082  		ld 			(__DSLoadGraphicData+1),hl
              	
              	; ****************************************************************************************************
              	;					Set up the pixel shifter for the 3 LSB of the x coordinate
              	; ****************************************************************************************************
              	
82DB: DD7E00  		ld 		a,(ix+0) 						; x 0-7 pixels
82DE: E607    		and 	7
82E0: 2804    		jr 		z,__DSOffsetDone 				; if zero, the JR will just fall through to register move
82E2: 3D      		dec 	a
82E3: 87      		add 	a,a	
82E4: C605    		add 	__DSShiftEntry-__DSShiftAHL-2
82E6:         	__DSOffsetDone:
82E6: 327383  		ld 		(__DSShiftAHL+1),a 				; set the JR offset.
              	
82E9: CD3683  		call 	__DSColourLine 					; colour the first line.
              	
              	; ****************************************************************************************************
              	;   						   S P R I T E     M A I N     L O O P
              	; ****************************************************************************************************
              	
82EC: 0610    		ld 			b,16 						; reset the draw counter to 16.
82EE:         	__DSMainLoop:
82EE: C5      		push 		bc
              	
              	; ****************************************************************************************************
              	;								XOR the graphic data into the screen
              	; ****************************************************************************************************
              	
82EF:         	__DSLoadGraphicData:
82EF: 210000  		ld 		hl,0000h 						; pointer to graphic data (modified in-line)
82F2: 56      		ld 		d,(hl) 							; read into DE
82F3: 23      		inc 	hl
82F4: 5E      		ld 		e,(hl)
82F5: 23      		inc 	hl
82F6: 22F082  		ld 		(__DSLoadGraphicData+1),hl 		; update graphic data pointer
              	
82F9: EB      		ex 		de,hl 							; 16 bit now in HL.
82FA: AF      		xor  	a 								; 24 bit graphic in AHL
              	
82FB: CD7283  		call 	__DSShiftAHL					; shift it accordingly
              	
82FE: EB      		ex 		de,hl 							; now it is in ADE
              	
82FF:         	__DSLoadScreenAddress:
82FF: 210000  		ld 		hl,0000h						; where we will write on the screen
              	
8302: AE      		xor 	(hl) 							; XOR those three bytes in to the screen
8303: 77      		ld 		(hl),a
8304: 2C      		inc 	l
8305: 7A      		ld 		a,d
8306: AE      		xor 	(hl)
8307: 77      		ld 		(hl),a
8308: 2C      		inc 	l
8309: 7B      		ld 		a,e
830A: AE      		xor 	(hl)
830B: 77      		ld 		(hl),a
830C: 2D      		dec 	l 								; unpick the increment so HL points to the first byte
830D: 2D      		dec 	l
              	
              	; ****************************************************************************************************
              	;										Move to the next line down
              	; ****************************************************************************************************
              	
830E: CD5E83  		call 	__DSHLDown 						; HL Down one line
8311: 220083  		ld 		(__DSLoadScreenAddress+1),hl 	; update the screen address.
              	
8314: 380F    		jr 		c,__DSHNoAttributeDown
              	
8316: E5      		push 	hl
8317: 2A3783  		ld 		hl,(__DSAttributeAddress+1)
831A: 112000  		ld 		de,32
831D: 19      		add 	hl,de
831E: 223783  		ld 		(__DSAttributeAddress+1),hl
8321: CD3683  		call 	__DSColourLine
8324: E1      		pop 	hl
              	
8325:         	__DSHNoAttributeDown:
              	
8325: C1      		pop 	bc 								; restore counter
8326: 7C      		ld 		a,h
8327: FE58    		cp 		58h								; into attribute memory ?
8329: 2802    		jr 		z,__DSExitEarly 				; off bottom of screen, end of sprite draw
              	
              	
832B: 10C1    		djnz	__DSMainLoop 					; keep going till done all lines, or reached the end of screen memory
              	
832D:         	__DSExitEarly:
832D: DD7E03  		ld 		a,(ix+3)						; toggle the erased/drawn bit
8330: EE80    		xor 	080h
8332: DD7703  		ld 		(ix+3),a
8335: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;										Colour the current line
              	;
              	; ****************************************************************************************************
              	
8336:         	__DSColourLine:
              		
8336:         	__DSAttributeAddress:
8336: 210000  		ld 		hl,0000 						; address to write colour to.
8339: DD7E02  		ld 		a,(ix+2)						; get attribute to write.
833C: B7      		or 		a
833D: C8      		ret 	z
              	
833E: DDCB037E		bit 	7,(ix+3) 						; if bit 7 is set (e.g. we are erasing)
8342: 200D    		jr 		nz,__DSCLErase
              	
8344: 77      		ld 		(hl),a 							; write 2 bytes out.
8345: 23      		inc 	hl
8346: 77      		ld 		(hl),a 
8347: 47      		ld 		b,a 							; save in B.
8348: DD7E00  		ld 		a,(ix+0) 						; do not write third attribute out if X mod 8 = 0, fits in two words.
834B: E607    		and 	7
834D: C8      		ret 	z
834E: 23      		inc 	hl 								; do the third attribute byte
834F: 70      		ld 		(hl),b
8350: C9      		ret
              	
8351:         	__DSCLErase:
8351: 5D      		ld 		e,l 							; copy HL to DE
8352: 54      		ld 		d,h
8353: 7C      		ld 		a,h 							; copy from $5C00-$5EFF to $5800-$5AFF
8354: C604    		add 	4	
8356: 67      		ld 		h,a
8357: EDA0    		ldi
8359: EDA0    		ldi
835B: EDA0    		ldi
835D: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;		Advance the line address HL down by 1, handles the slightly odd screen arrangement
              	;
              	;							If CY clear, then we have changed attribute byte.
              	;
              	; ****************************************************************************************************
              	
835E:         	__DSHLDown:
835E: 24      		inc 	h 								; next line down.
835F: 7C      		ld 		a,h 							; have we stepped over the border
8360: E607    		and 	7
8362: 37      		scf 									; if we haven't, return with CY set.
8363: C0      		ret 	nz
              	
8364: 7C      		ld 		a,h 							; fix up three lower bits of high address byte
8365: D608    		sub 	8
8367: 67      		ld 		h,a
              	
8368: 7D      		ld 		a,l 							; next block of 8 down, high 3 bits of low address byte
8369: C620    		add 	32
836B: 6F      		ld 		l,a
836C: D0      		ret		nc
              	
836D: 7C      		ld 		a,h 							; next page down ; also it will clear the carry.
836E: C608    		add 	8
8370: 67      		ld 		h,a
8371: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;	Shift the 24 bit value AHL left a number of times defined by the x coordinate, set up at the
              	;	start of the drawing routine.
              	;
              	; ****************************************************************************************************
              	
8372:         	__DSShiftAHL:
8372: 1805    		jr 		__DSShiftEntry 					; this jump vector is zero if x % 8 = 0, otherwise it jumps into code below to shift
8374: 7C      		ld 		a,h
8375: 65      		ld 		h,l
8376: 2E00    		ld 		l,0
8378: C9      		ret
              	
8379:         	__DSShiftEntry:
8379: 29      		add 	hl,hl 							; the JR at __DSShiftEntry jumps into this code.
837A: 8F      		adc 	a,a
837B: 29      		add 	hl,hl
837C: 8F      		adc 	a,a
837D: 29      		add 	hl,hl
837E: 8F      		adc 	a,a
837F: 29      		add 	hl,hl
8380: 8F      		adc 	a,a
              	
8381: 29      		add 	hl,hl
8382: 8F      		adc 	a,a
8383: 29      		add 	hl,hl
8384: 8F      		adc 	a,a
8385: 29      		add 	hl,hl
8386: 8F      		adc 	a,a
8387: C9      		ret
              	
              	
              	; ****************************************************************************************************
              	
8388:         	TSDraw:
8388: CD8E82  		call 	CopyAttributeToShadow
838B: DD21B483		ld 		ix,testSprite
838F:         	TSLoop:
838F: CD9A82  		call 	__DSDrawSprite
8392:         	TSDelay:
8392: 21E803  		ld 		hl,1000
8395:         	TSDelay1:
8395: 2B      		dec 	hl
8396: 7C      		ld 		a,h
8397: B5      		or 		l
8398: 20FB    		jr 		nz,TSDelay1
839A: CD9A82  		call 	__DSDrawSprite
839D: DD3400  		inc 	(ix+0)
83A0: DD3401  		inc 	(ix+1)
83A3: DD7E01  		ld 		a,(ix+1)
83A6: FEA0    		cp 		160
83A8: 20E5    		jr 		nz,TSLoop
83AA: DD360040		ld 		(ix+0),64
83AE: DD360120		ld 		(ix+1),32
83B2: 18DB    		jr 		TSLoop
              	
83B4:         	testSprite:
83B4: 43      		defb 	67
83B5: 23      		defb 	35		
83B6: 4600    		defb 	046h,0
83B8: BC830000		defw 	graphicData,0
              	
83BC:         	graphicData:
83BC: FFFF    		defb 	0FFh,0FFh
83BE: AAAA    		defb 	0AAh,0AAh
83C0: 8003    		defb 	080h,003h
83C2: 8007    		defb 	080h,007h
              	
83C4: 8F0F    		defb 	08Fh,00Fh
83C6: 801F    		defb 	080h,01Fh
83C8: FFE0    		defb 	0FFh,0E0h
83CA: 0200    		defb 	002h,000h
              	
83CC: 0200    		defb 	002h,000h
83CE: 0700    		defb 	007h,000h
83D0: 8001    		defb 	080h,001h
83D2: 8001    		defb 	080h,001h
              	
83D4: 8001    		defb 	080h,001h
83D6: 8001    		defb 	080h,001h
83D8: 8001    		defb 	080h,001h
83DA: FFFF    		defb 	0FFh,0FFh
              	
              	
83DC:         	BootWord:
83DC: FDE9    		jp 			(iy)
83DE: BB81    		defw 		WORD_ClearScreen
83E0: E883    		defw 		WORD_Star
83E2: 8182    		defw 		WORD_Test
83E4: E883    		defw 		WORD_Star
83E6: 7181    		defw 		WORD_Stop
              	
83E8:         	WORD_Star:
83E8: FDE9    		jp 			(iy)
83EA: 2980    		defw 		Core_Literal
83EC: 2A00    		defw 		42
83EE: 8981    		defw 		WORD_Emit
83F0: 3180    		defw 		Core_Return
              	
83F2:         	EndOfCode:
              	
              	; ****************************************************************************************************
              	;
              	;												Examples
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	Code word (example) DUP. Note that in code words DE is the code pointer.
              	;	We just go straight in with the machine code. Code words can only use HL as a temporary value
              	; 	so for things like + use EXX and do it in the alternate set.
              	;
              	;
              	;dup:										; <<dup>>
              	;	pop 	hl
              	;	push 	hl
              	;	push 	hl
              	;	jp		(ix)							; and fix up so HL is the code pointer again and loop
              	;
              	;
              	;
              	;	Word built up out of other definitions.
              	;	
              	;	jp 		(iy)							; identifies as a word from words.
              	;
              	;	; first def addr
              	;	; second def addr
              	;	;	..
              	;	;	..
              	;
              	;	defw 	Core_Return 					; now we want to go back.
              	;
              	
              	
              	


total time: 0.0024 sec.
no errors
