              	; --------------------------------------
              	; zasm: assemble "forth.asm"
              	; date: 2017-05-14 23:14:40
              	; --------------------------------------


              	; ****************************************************************************************************
              	;
              	;									Forth Compiler Runtime
              	;
              	; ****************************************************************************************************
              	
              		include 	"sna_header.asm"			; .SNA boot header
              	; *****************************************************************************************
              	; *****************************************************************************************
              	;
              	;                       SNA Header - variant of the provided example.
              	;
              	; *****************************************************************************************
              	; *****************************************************************************************
              	
              	#target sna
              	
              	; *****************************************************************************************
              	;
              	;                               saved registers, restored in NMI
              	;
              	; *****************************************************************************************
              	
0000:         	#code HEAD, 0, 27
0000: 3F      	    defb    $3f             ; i
0001: 0000    	    defw    0               ; hl'
0003: 0000    	    defw    0               ; de'
0005: 0000    	    defw    0               ; bc'
0007: 0000    	    defw    0               ; af'
              	
0009: 0000    	    defw    0               ; hl
000B: 0000    	    defw    0               ; de
000D: 0000    	    defw    0               ; bc
000F: 0000    	    defw    0               ; iy
0011: 0000    	    defw    0               ; ix
              	
0013: 00      	    defb    0<<2            ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei
0014: 000000  	    defb    0,0,0           ; r,f,a
0017: 035B    	    defw    __stackEnd      ; sp
0019: 01      	    defb    1               ; irpt mode
001A: 00      	    defb    0               ; border color: 0=black ... 7=white
              	
              	; *****************************************************************************************
              	;
              	;                   $4000-$7FFF. Pixel Memory, Attribute Memory, Slow RAM
              	;
              	; *****************************************************************************************
              	
4000:         	#code SLOW_RAM, 0x4000, 0x4000
              	
4000:         	VideoMemory:
4000: 00000000	    defs    0x1800
4004: 00...   	
5800:         	AttributeMemory:
5800: 00000000	    defs    0x300
5804: 00...   	
5B00:         	EndVideoMemory:
              	;
              	;   Boot. We fill video RAM with random stuff just so we know we are working.
              	;
5B00:         	__bootSNA:
5B00: C30480  	    jp      start
              	
              	; *****************************************************************************************
              	;
              	;                            $8000-$FFFF. Non contentious memory
              	;
              	; *****************************************************************************************
              	
5B03:         	__stackEnd:   
5B03: 005B    	    defw    __bootSNA
              	
8000:         	#code FAST_RAM, 0x8000, 0x8000
              	
              		include 	"core4.asm" 				; Forth core (Direct Threaded)
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;													Core v4
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
8000:         	BootAddress:
8000: 9E81    		defw 	BootWord 						; start of threaded word.
8002:         	FreeAddress:
8002: C681    		defw 	EndOfCode 						; end of code that is built with the assembler.
              		
8004:         	start:
8004: DD212280		ld 		ix,Core_Continue  				; these allow us to do fast jumps in and out of routines.
8008: FD211980		ld 		iy,Core_Call 					; also saving a byte on long jumps.
              	
800C: 310000  		ld 		sp,0x0000 						; sp is the data stack (works down)
800F: 0100FF  		ld 		bc,0xFF00 						; bc is the return stack (works up)
              	
8012: 2A0080  		ld 		hl,(BootAddress)				; hl is the IP (except when executing Z80 code words)
8015: 23      		inc 	hl 								; skip over the JP (IY)
8016: 23      		inc 	hl
8017: 180A    		jr 		Core_Execute
              	
              	; ****************************************************************************************************
              	;
              	;		The JP (IY) at the start of a threaded definition comes here. DE contains
              	; 		the old address, HL the new one.
              	;
              	;		Save the calling address on the stack and execute from HL. Which handily is in HL.
              	;
              	; ****************************************************************************************************
              	
8019:         	Core_Call:
8019: 23      		inc 	hl 								; advance HL over the JP(IY) $FD $E9
801A: 23      		inc 	hl 								; now points to the first definition
              	
801B: 7B      		ld 		a,e 							; push DE (old address) on the BC stack.
801C: 03      		inc 	bc 								; unfortunately a Z80 only has one stack, so we have
801D: 02      		ld 		(bc),a 							; to use it for either data *or* return.
801E: 7A      		ld 		a,d
801F: 03      		inc 	bc
8020: 02      		ld 		(bc),a
              	
8021: EB      		ex 		de,hl 							; allows us to fall through to execute loop
              	
              	; ****************************************************************************************************
              	;
              	;	Ending a machine code definition comes here (using JP (IX)). We need this exchange
              	; 	because when running m/c definition DE is the instruction pointer
              	;
              	; ****************************************************************************************************
              	
8022:         	Core_Continue:
8022: EB      		ex 		de,hl 							; if executing code word come back here.
              	
              	; ****************************************************************************************************
              	;
              	;					Main execution entry point. Execute instruction at (DE)
              	;
              	; ****************************************************************************************************
              	
8023:         	Core_Execute:
8023: 5E      		ld 		e,(hl)							; read address of next word at HL into DE, LSB first
8024: 23      		inc 	hl
8025: 56      		ld 		d,(hl)
8026: 23      		inc 	hl
8027: EB      		ex 		de,hl 							; swap so when executing code word DE code ptr and so we can 
8028: E9      		jp 		(hl) 							; do this 4 cycle jump
              	
              	; ****************************************************************************************************
              	;
              	;											16 bit literal word
              	;
              	; ****************************************************************************************************
              	
8029:         	Core_Literal:								; <<.literal>>
8029: EB      		ex 		de,hl 							; HL now contains the IP back again.
802A: 5E      		ld 		e,(hl) 							; load next word into DE
802B: 23      		inc 	hl
802C: 56      		ld 		d,(hl)
802D: 23      		inc 	hl
802E: D5      		push 	de 								; push word on data stack
802F: 18F2    		jr 		Core_Execute 					; and execute without doing the DE/HL swap
              	
              	; ****************************************************************************************************
              	;
              	;												Return word.
              	;
              	; ****************************************************************************************************
              	
8031:         	Core_Return:								; <<;>>
8031: 0A      		ld 		a,(bc) 							; pop address into DE.
8032: 0B      		dec 	bc
8033: 57      		ld 		d,a 
8034: 0A      		ld 		a,(bc)
8035: 0B      		dec 	bc
8036: 5F      		ld 		e,a
8037: DDE9    		jp 		(ix) 							; this will put DE -> HL and start executing one level up.
              	
              		include 	"library.asm" 				; Basic FORTH words
              	; ****************************************************************************************************
              	;
              	;								 Basic FORTH Library, Z80 Assembler
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	over rot pick
              	;	1+ 1- 2+ 2- 2* 16* 256* 2/ 16/ 256/ 0= 0- 0< 
              	;	br bz bpl r> >r rdrop
              	;
              		include "library/binary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Binary)
              	;
              	; ****************************************************************************************************
              	
8039:         	WORD_Add:									; <<+>>
8039: D9      		exx 
803A: E1      		pop		hl
803B: D1      		pop 	de
803C: 19      		add 	hl,de
803D: E5      		push 	hl
803E: D9      		exx
803F: DDE9    		jp 		(ix)
              	
8041:         	WORD_Subtract: 								; <<->>
8041: D9      		exx 
8042: D1      		pop 	de
8043: E1      		pop 	hl
8044: AF      		xor 	a
8045: ED52    		sbc 	hl,de
8047: E5      		push 	hl
8048: D9      		exx 	
8049: DDE9    		jp 		(ix)
              	
804B:         	WORD_And:									; <<and>>
804B: D9      		exx
804C: D1      		pop 	de
804D: E1      		pop 	hl
804E: 7C      		ld 		a,h 							; do MSB
804F: A2      		and 	d
8050: 67      		ld 		h,a
8051: 7D      		ld 		a,l 							; do LSB
8052: A3      		and 	e
8053:         	__WORD_Logic_Exit:
8053: 6F      		ld 		l,a 							
8054: E5      		push 	hl
8055: D9      		exx
8056: DDE9    		jp 		(ix)
              	
8058:         	WORD_Xor:									; <<xor>>
8058: D9      		exx
8059: D1      		pop 	de
805A: E1      		pop 	hl
805B: 7C      		ld 		a,h 							; do MSB
805C: AA      		xor 	d
805D: 67      		ld 		h,a
805E: 7D      		ld 		a,l 							; do LSB
805F: AB      		xor 	e
8060: 18F1    		jr 		__WORD_Logic_Exit
              	
8062:         	WORD_Or:									; <<or>>
8062: D9      		exx
8063: D1      		pop 	de
8064: E1      		pop 	hl
8065: 7C      		ld 		a,h 							; do MSB
8066: B2      		or 		d
8067: 67      		ld 		h,a
8068: 7D      		ld 		a,l 							; do LSB
8069: B3      		or 		e
806A: 18E7    		jr 		__WORD_Logic_Exit
              	
              		include "library/unary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Unary)
              	;
              	; ****************************************************************************************************
              	
              	
              		include "library/constants.asm"
              	; ****************************************************************************************************
              	;
              	;						Constants, quicker and shorter versions of .literal
              	;
              	; ****************************************************************************************************
              	
              	ConstantWord macro value
              		ld 		hl,&value 						; <<&value>>
              		push 	hl
              		jp 		(ix)
              		endm
              	;
              	;	If you use these (which the compiler does automatically) it saves two bytes over .literal [n]
              	;	and also is several cycles quicker, because it doesn't fetch the value. A similar system is
              	;	used for variables/arrays/constants as these are all 6 bytes long (same as .literal [n] return)
              	;
              		ConstantWord 	-1
806C: 21FFFF  		ld 		hl,-1 						; <<-1>>
806F: E5      		push 	hl
8070: DDE9    		jp 		(ix)
              		ConstantWord 	0	
8072: 210000  		ld 		hl,0 						; <<0>>
8075: E5      		push 	hl
8076: DDE9    		jp 		(ix)
              		ConstantWord 	1
8078: 210100  		ld 		hl,1 						; <<1>>
807B: E5      		push 	hl
807C: DDE9    		jp 		(ix)
              		ConstantWord 	2
807E: 210200  		ld 		hl,2 						; <<2>>
8081: E5      		push 	hl
8082: DDE9    		jp 		(ix)
              		ConstantWord 	4
8084: 210400  		ld 		hl,4 						; <<4>>
8087: E5      		push 	hl
8088: DDE9    		jp 		(ix)
              		ConstantWord 	8
808A: 210800  		ld 		hl,8 						; <<8>>
808D: E5      		push 	hl
808E: DDE9    		jp 		(ix)
              		ConstantWord 	10
8090: 210A00  		ld 		hl,10 						; <<10>>
8093: E5      		push 	hl
8094: DDE9    		jp 		(ix)
              		ConstantWord 	16
8096: 211000  		ld 		hl,16 						; <<16>>
8099: E5      		push 	hl
809A: DDE9    		jp 		(ix)
              		ConstantWord 	100
809C: 216400  		ld 		hl,100 						; <<100>>
809F: E5      		push 	hl
80A0: DDE9    		jp 		(ix)
              		ConstantWord 	256
80A2: 210001  		ld 		hl,256 						; <<256>>
80A5: E5      		push 	hl
80A6: DDE9    		jp 		(ix)
              	
              		include "library/stack.asm"
              	; ****************************************************************************************************
              	;
              	;										  Stack Manipulation
              	;
              	; ****************************************************************************************************
              	
80A8:         	WORD_Dup:									; <<dup>>
80A8: E1      		pop 	hl 								; get TOS and push it back twice
80A9: E5      		push 	hl
80AA: E5      		push 	hl
80AB: DDE9    		jp 		(ix) 							; return 
              	
80AD:         	WORD_Drop:									; <<drop>>
80AD: E1      		pop 	hl
80AE: DDE9    		jp 		(ix)
              	
80B0:         	WORD_Swap:									; <<swap>>
80B0: D9      		exx 									; use alt register set
80B1: E1      		pop 	hl 								; get TOS and push it back twice
80B2: D1      		pop 	de
80B3: E5      		push 	hl
80B4: D5      		push 	de
80B5: D9      		exx 
80B6: DDE9    		jp 		(ix) 							; return 
              	
              		include "library/io.asm"
              	; ****************************************************************************************************
              	;
              	;										Input/Output functions
              	;
              	; ****************************************************************************************************
              	
80B8:         	WORD_Emit:									; <<emit>>
80B8: E1      		pop 	hl 								; get character to print in L
80B9: CDE880  		call	PrintCharL
80BC: DDE9    		jp 		(ix)
              	
80BE:         	WORD_PrintInteger:							; <<.>>
80BE: E1      		pop 	hl
80BF: CD4681  		call 	PrintInteger
80C2: DDE9    		jp 		(ix)
              	
80C4:         	WORD_PrintStack:							; <<.stack>>
80C4: D5      		push 	de 								; save DE
80C5: 210000  		ld 		hl,0  							; get SP into HL
80C8: 23      		inc 	hl 								; skip over PUSH DE above
80C9: 23      		inc 	hl
80CA: 39      		add 	hl,sp
80CB:         	__PSLoop:
80CB: 5E      		ld 		e,(hl) 							; load into DE
80CC: 23      		inc 	hl
80CD: 56      		ld 		d,(hl)
80CE: 23      		inc 	hl
80CF: EB      		ex 		de,hl 							; print it
80D0: CD4681  		call 	PrintInteger
80D3: EB      		ex 		de,hl
80D4: 7C      		ld 		a,h 							; reached top of stack
80D5: B7      		or 		a
80D6: 20F3    		jr 		nz,__PSLoop
80D8: D1      		pop 	de 								; restore DE
80D9: 2E0D    		ld 		l,13 							; print CR
80DB: CDE880  		call 	PrintCharL
80DE: DDE9    		jp 		(ix)
              	
80E0:         	WORD_ClearScreen:							; <<cls>>
80E0: CD6D81  		call 	ClearScreen
80E3: CD8781  		call 	HomeCursor
80E6: DDE9    		jp 		(ix)
              	
              	; ****************************************************************************************************
              	;			This is included if io.asm is included, provides direct I/O to Speccy hardware
              	; ****************************************************************************************************
              	
              		include "utils/screen.asm" 				; Screen I/O routines.
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;			Replacement for Spectrums Screen Display Routine, straight 32x24 video display
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;							Print character in L ; all registers preserved.
              	;
              	; ****************************************************************************************************
              	
80E8:         	PrintCharL:
80E8: F5      		push 	af 								; stack registers
80E9: C5      		push 	bc 								
80EA: D5      		push 	de
80EB: E5      		push 	hl
              	
80EC: 7D      		ld 		a,l 							; check for CR ?
80ED: FE0D    		cp 		13
80EF: 2847    		jr		z,__PCLReturn
              	
80F1: 0600    		ld 		b,0 							; B is the reversing byte
80F3: CB7D    		bit 	7,l 							; if bit 7 set
80F5: 2803    		jr 		z,__PCANotReverse
80F7: 05      		dec 	b 								; B becomes $FF
80F8: CBBD    		res 	7,l 							; drop bit 7
80FA:         	__PCANotReverse:
80FA: 2600    		ld 		h,0 							; HL to 16 bit
80FC: ED5B9581		ld 		de,(__PCAFont)					; DE = Font Base
8100: 29      		add 	hl,hl 							; calc Font Base + char * 8
8101: 29      		add 	hl,hl
8102: 29      		add 	hl,hl
8103: 19      		add 	hl,de
8104: EB      		ex 		de,hl 							; put in DE
8105: 2A9781  		ld 		hl,(__PCAVideoPos) 				; get write address
8108: E5      		push 	hl 								; save for later
8109:         	_PCALoop:	
8109: 1A      		ld 		a,(de) 							; read font char
810A: A8      		xor 	b 								; reverse byte
810B: 77      		ld 		(hl),a 							; write to screen
810C: 1C      		inc 	e 								; bump pointers
810D: 24      		inc 	h
810E: 7C      		ld 		a,h 							; until done whole row
810F: E607    		and 	7
8111: 20F6    		jr 		nz,_PCALoop
              	
              	
8113: ED5B9981		ld 		de,(__PCAAttribPos)				; copy colour byte to attribute memory.
8117: 3A9B81  		ld 		a,(__PCAColour)
811A: 12      		ld 		(de),a
811B: 13      		inc 	de
              	
811C: E1      		pop 	hl 								; restore original video position to HL
811D: 2C      		inc 	l 								; right one
811E: 200C    		jr 		nz,__PCANotNewPage 				; if nz don't need new 1/4k page
8120: 7C      		ld 		a,h 							; advance to next quarter page
8121: C608    		add 	8
8123: 67      		ld 		h,a 	
8124: FE58    		cp 		0x58 							; we only have 3, this is the attribute page
8126: 2004    		jr 		nz,__PCANotNewPage
8128: 2640    		ld 		h,0x40 							; wrap round to top.
812A: 1658    		ld 		d,0x58 							; reset attribute memory pointer
812C:         	__PCANotNewPage:
812C: 229781  		ld 		(__PCAVideoPos),hl 				; update new position in video / attr
812F: ED539981		ld 		(__PCAAttribPos),de 			
              	
8133:         	__PCLExit:
8133: E1      		pop 	hl 								; destack.
8134: D1      		pop 	de
8135: C1      		pop 	bc
8136: F1      		pop 	af
8137: C9      		ret
              	
8138:         	__PCLReturn: 								; carriage return.
8138: 2E20    		ld 		l,' '
813A: CDE880  		call 	PrintCharL
813D: 3A9781  		ld 		a,(__PCAVideoPos)
8140: E61F    		and 	31
8142: 20F4    		jr 		nz,__PCLReturn
8144: 18ED    		jr 		__PCLExit
              	
              	; ****************************************************************************************************
              	;
              	;									Print HL in hexadecimal
              	;
              	; ****************************************************************************************************
              	
8146:         	PrintInteger:
8146: E5      		push 	hl
8147: 2E20    		ld 		l,' ' 							; print leading space
8149: CDE880  		call 	PrintCharL
814C: E1      		pop 	hl
814D: 7C      		ld 		a,h
814E: CD5681  		call 	PrintByteA
8151: 7D      		ld 		a,l
8152: CD5681  		call 	PrintByteA
8155: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;									Print Byte in Hexadecimal
              	;
              	; ****************************************************************************************************
              	
8156:         	PrintByteA:
8156: F5      		push 	af 								; save A on stack
8157: 1F      		rra 									; shift right 4
8158: 1F      		rra
8159: 1F      		rra
815A: 1F      		rra
815B: CD5F81  		call	__PBANibble 					; print it
815E: F1      		pop 	af 								; restore
815F:         	__PBANibble:
815F: F6F0    		or 		0F0h 							; DAA trick
8161: 27      		daa
8162: C6A0    		add 	a,0A0h
8164: CE40    		adc 	a,040h
8166: E5      		push 	hl 								; print character
8167: 6F      		ld 		l,a
8168: CDE880  		call 	PrintCharL
816B: E1      		pop 	hl
816C: C9      		ret
              	
              	; ****************************************************************************************************
              	;	
              	;											Clear Screen
              	;
              	; ****************************************************************************************************
              	
816D:         	ClearScreen:
816D: E5      		push 	hl
816E: 210040  		ld 		hl,0x4000 						; fill 4000-57FF with zero
8171:         	__CLSLoop1:
8171: 3600    		ld 		(hl),0
8173: 23      		inc 	hl
8174: 7C      		ld 		a,h
8175: FE58    		cp 		0x58
8177: 20F8    		jr		nz,__CLSLoop1
8179:         	__CLSLoop2:									; fill 5800-5FFF with 7 (white)
8179: 3607    		ld 		(hl),7
817B: 23      		inc 	hl
817C: 7C      		ld 		a,h
817D: FE60    		cp 		0x60
817F: 20F8    		jr		nz,__CLSLoop2
8181: 3E01    		ld 		a,1 							; set border to blue.
8183: D3FE    		out 	(0xFE),a
8185: E1      		pop 	hl
8186: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Home Cursor
              	;
              	; ****************************************************************************************************
              	
8187:         	HomeCursor:	
8187: E5      		push 	hl
8188: 210058  		ld 		hl,0x5800 						; reset attribute pos
818B: 229981  		ld 		(__PCAAttribPos),hl
818E: 2640    		ld 		h,0x40 							; reset video pos
8190: 229781  		ld 		(__PCAVideoPos),hl
8193: E1      		pop 	hl
8194: C9      		ret
              	
8195:         	__PCAFont: 									; font base here
8195: 003C    		defw 	0x3C00
8197:         	__PCAVideoPos: 								; current video memory pointer.
8197: 0040    		defw 	VideoMemory
8199:         	__PCAAttribPos:								; current attribute pointer
8199: 0058    		defw 	AttributeMemory
819B:         	__PCAColour: 								; current colour to use
819B: 44      		defb 	0x44
              		include "library/misc.asm"
              	; ****************************************************************************************************
              	;
              	; 												Miscellany
              	;
              	; ****************************************************************************************************
              	
819C:         	WORD_Stop:									; <<stop>>
819C: 18FE    		jr 		WORD_Stop
              	
              	
              	
819E:         	BootWord:
819E: FDE9    		jp 			(iy)
81A0: E080    		defw 		WORD_ClearScreen
81A2: BC81    		defw 		WORD_Star
81A4: BC81    		defw 		WORD_Star
81A6: BC81    		defw 		WORD_Star
              	
81A8: 2980    		defw 		Core_Literal
81AA: 0100    		defw 		1
81AC: 2980    		defw 		Core_Literal
81AE: 0200    		defw 		2
81B0: 2980    		defw 		Core_Literal
81B2: 0300    		defw 		3
81B4: 2980    		defw 		Core_Literal
81B6: 0400    		defw 		4
              		
81B8: C480    		defw 		WORD_PrintStack
81BA: 9C81    		defw 		WORD_Stop
              	
81BC:         	WORD_Star:
81BC: FDE9    		jp 			(iy)
81BE: 2980    		defw 		Core_Literal
81C0: 2A00    		defw 		42
81C2: B880    		defw 		WORD_Emit
81C4: 3180    		defw 		Core_Return
              	
81C6:         	EndOfCode:
              	
              	; ****************************************************************************************************
              	;
              	;												Examples
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	Code word (example) DUP. Note that in code words DE is the code pointer.
              	;	We just go straight in with the machine code. Code words can only use HL as a temporary value
              	; 	so for things like + use EXX and do it in the alternate set.
              	;
              	;
              	;dup:										; <<dup>>
              	;	pop 	hl
              	;	push 	hl
              	;	push 	hl
              	;	jp		(ix)							; and fix up so HL is the code pointer again and loop
              	;
              	;
              	;
              	;	Word built up out of other definitions.
              	;	
              	;	jp 		(iy)							; identifies as a word from words.
              	;
              	;	; first def addr
              	;	; second def addr
              	;	;	..
              	;	;	..
              	;
              	;	defw 	Core_Return 					; now we want to go back.
              	;
              	
              	
              	


total time: 0.0033 sec.
no errors
