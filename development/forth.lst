              	; --------------------------------------
              	; zasm: assemble "forth.asm"
              	; date: 2017-05-15 17:08:40
              	; --------------------------------------


              	; ****************************************************************************************************
              	;
              	;									Forth Compiler Runtime
              	;
              	; ****************************************************************************************************
              	
              		include 	"sna_header.asm"			; .SNA boot header
              	; *****************************************************************************************
              	; *****************************************************************************************
              	;
              	;                       SNA Header - variant of the provided example.
              	;
              	; *****************************************************************************************
              	; *****************************************************************************************
              	
              	#target sna
              	
              	; *****************************************************************************************
              	;
              	;                               saved registers, restored in NMI
              	;
              	; *****************************************************************************************
              	
0000:         	#code HEAD, 0, 27
0000: 3F      	    defb    $3f             ; i
0001: 0000    	    defw    0               ; hl'
0003: 0000    	    defw    0               ; de'
0005: 0000    	    defw    0               ; bc'
0007: 0000    	    defw    0               ; af'
              	
0009: 0000    	    defw    0               ; hl
000B: 0000    	    defw    0               ; de
000D: 0000    	    defw    0               ; bc
000F: 0000    	    defw    0               ; iy
0011: 0000    	    defw    0               ; ix
              	
0013: 00      	    defb    0<<2            ; bit 2 = iff2 (iff1 before nmi) 0=di, 1=ei
0014: 000000  	    defb    0,0,0           ; r,f,a
0017: 035B    	    defw    __stackEnd      ; sp
0019: 01      	    defb    1               ; irpt mode
001A: 00      	    defb    0               ; border color: 0=black ... 7=white
              	
              	; *****************************************************************************************
              	;
              	;                   $4000-$7FFF. Pixel Memory, Attribute Memory, Slow RAM
              	;
              	; *****************************************************************************************
              	
4000:         	#code SLOW_RAM, 0x4000, 0x4000
              	
4000:         	VideoMemory:
4000: 00000000	    defs    0x1800
4004: 00...   	
5800:         	AttributeMemory:
5800: 00000000	    defs    0x300
5804: 00...   	
5B00:         	EndVideoMemory:
              	
5B00:         	__bootSNA:
5B00: C30480  	    jp      start
              	
              	; *****************************************************************************************
              	;
              	;                            $8000-$FFFF. Non contentious memory
              	;
              	; *****************************************************************************************
              	
5B03:         	__stackEnd:   
5B03: 005B    	    defw    __bootSNA
              	
8000:         	#code FAST_RAM, 0x8000, 0x8000
              	
              		include 	"core4.asm" 				; Forth core (Direct Threaded)
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;													Core v4
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;	These words are accessed/changed by the compiler, so it knows (i) where to start the program
              	;	and (ii) where it can compile code.
              	;
              	; ****************************************************************************************************
              	
8000:         	BootAddress:
8000: 6083    		defw 	BootWord 						; start of threaded word.
8002:         	FreeAddress:
8002: 7F83    		defw 	EndOfCode 						; end of code that is built with the assembler.
              	
              	; ****************************************************************************************************
              	;
              	;										Start Forth Core
              	;
              	; ****************************************************************************************************
              		
8004:         	start:
8004: DD212280		ld 		ix,Core_Continue  				; these allow us to do fast jumps in and out of routines.
8008: FD211980		ld 		iy,Core_Call 					; also saving a byte on long jumps.
              	
800C: 310000  		ld 		sp,0x0000 						; sp is the data stack (works down)
800F: 0100FF  		ld 		bc,0xFF00 						; bc is the return stack (works up)
              	
8012: 2A0080  		ld 		hl,(BootAddress)				; hl is the IP (except when executing Z80 code words)
8015: 23      		inc 	hl 								; skip over the JP (IY)
8016: 23      		inc 	hl
8017: 180A    		jr 		Core_Execute
              	
              	; ****************************************************************************************************
              	;
              	;		The JP (IY) at the start of a threaded definition comes here. DE contains
              	; 		the old address, HL the new one.
              	;
              	;		Save the calling address on the stack and execute from HL. Which handily is in HL.
              	;
              	; ****************************************************************************************************
              	
8019:         	Core_Call:
8019: 23      		inc 	hl 								; advance HL over the JP(IY) $FD $E9
801A: 23      		inc 	hl 								; now points to the first definition
              	
801B: 7B      		ld 		a,e 							; push DE (old address) on the BC stack.
801C: 03      		inc 	bc 								; unfortunately a Z80 only has one stack, so we have
801D: 02      		ld 		(bc),a 							; to use it for either data *or* return.
801E: 7A      		ld 		a,d
801F: 03      		inc 	bc
8020: 02      		ld 		(bc),a
              	
8021: EB      		ex 		de,hl 							; allows us to fall through to execute loop
              	
              	; ****************************************************************************************************
              	;
              	;	Ending a machine code definition comes here (using JP (IX)). We need this exchange
              	; 	because when running m/c definition DE is the instruction pointer
              	;
              	; ****************************************************************************************************
              	
8022:         	Core_Continue:
8022: EB      		ex 		de,hl 							; if executing code word come back here.
              	
              	; ****************************************************************************************************
              	;
              	;					Main execution entry point. Execute instruction at (DE)
              	;
              	; ****************************************************************************************************
              	
8023:         	Core_Execute:
8023: 5E      		ld 		e,(hl)							; read address of next word at HL into DE, LSB first
8024: 23      		inc 	hl
8025: 56      		ld 		d,(hl)
8026: 23      		inc 	hl
8027: EB      		ex 		de,hl 							; swap so when executing code word DE code ptr and so we can 
8028: E9      		jp 		(hl) 							; do this 4 cycle jump
              	
              	; ****************************************************************************************************
              	;
              	;											16 bit literal word
              	;
              	; ****************************************************************************************************
              	
8029:         	Core_Literal:								; <<.literal>>
8029: EB      		ex 		de,hl 							; HL now contains the IP back again.
802A: 5E      		ld 		e,(hl) 							; load next word into DE
802B: 23      		inc 	hl
802C: 56      		ld 		d,(hl)
802D: 23      		inc 	hl
802E: D5      		push 	de 								; push word on data stack
802F: 18F2    		jr 		Core_Execute 					; and execute without doing the DE/HL swap
              	
              	; ****************************************************************************************************
              	;
              	;												Return word.
              	;
              	; ****************************************************************************************************
              	
8031:         	Core_Return:								; <<;>>
8031: 0A      		ld 		a,(bc) 							; pop address into DE.
8032: 0B      		dec 	bc
8033: 57      		ld 		d,a 
8034: 0A      		ld 		a,(bc)
8035: 0B      		dec 	bc
8036: 5F      		ld 		e,a
8037: DDE9    		jp 		(ix) 							; this will put DE -> HL and start executing one level up.
              	
              		include 	"library.asm" 				; Basic FORTH words including optional text/sprite stuff
              	; ****************************************************************************************************
              	;
              	;								 Basic FORTH Library, Z80 Assembler
              	;
              	; ****************************************************************************************************
              	
              		include "library/binary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Binary)
              	;
              	; ****************************************************************************************************
              	
8039:         	WORD_Add:									; <<+>>
8039: D9      		exx 
803A: E1      		pop		hl
803B: D1      		pop 	de
803C: 19      		add 	hl,de
803D: E5      		push 	hl
803E: D9      		exx
803F: DDE9    		jp 		(ix)
              	
8041:         	WORD_Subtract: 								; <<->>
8041: D9      		exx 
8042: D1      		pop 	de
8043: E1      		pop 	hl
8044: AF      		xor 	a
8045: ED52    		sbc 	hl,de
8047: E5      		push 	hl
8048: D9      		exx 	
8049: DDE9    		jp 		(ix)
              	
804B:         	WORD_And:									; <<and>>
804B: D9      		exx
804C: D1      		pop 	de
804D: E1      		pop 	hl
804E: 7C      		ld 		a,h 							; do MSB
804F: A2      		and 	d
8050: 67      		ld 		h,a
8051: 7D      		ld 		a,l 							; do LSB
8052: A3      		and 	e
8053:         	__WORD_Logic_Exit:
8053: 6F      		ld 		l,a 							
8054: E5      		push 	hl
8055: D9      		exx
8056: DDE9    		jp 		(ix)
              	
8058:         	WORD_Xor:									; <<xor>>
8058: D9      		exx
8059: D1      		pop 	de
805A: E1      		pop 	hl
805B: 7C      		ld 		a,h 							; do MSB
805C: AA      		xor 	d
805D: 67      		ld 		h,a
805E: 7D      		ld 		a,l 							; do LSB
805F: AB      		xor 	e
8060: 18F1    		jr 		__WORD_Logic_Exit
              	
8062:         	WORD_Or:									; <<or>>
8062: D9      		exx
8063: D1      		pop 	de
8064: E1      		pop 	hl
8065: 7C      		ld 		a,h 							; do MSB
8066: B2      		or 		d
8067: 67      		ld 		h,a
8068: 7D      		ld 		a,l 							; do LSB
8069: B3      		or 		e
806A: 18E7    		jr 		__WORD_Logic_Exit
              	
              		include "library/unary.asm"
              	; ****************************************************************************************************
              	;
              	;									Arithmetic and Logic (Unary)
              	;
              	; ****************************************************************************************************
              	
              	; abs sgn
              	
806C:         	WORD_0Minus:								; <<0->>
806C: D9      		exx
806D: D1      		pop 	de
806E: 210000  		ld 		hl,0
8071: AF      		xor 	a
8072: ED52    		sbc 	hl,de
8074: E5      		push 	hl
8075: D9      		exx 	
8076: DDE9    		jp 		(ix)
              	
8078:         	WORD_0Equals:
8078: E1      		pop 	hl 								; <<0=>>
8079: 7C      		ld 		a,h
807A: B5      		or 		l
807B: 2806    		jr 		z,__UNPushTrue
807D:         	__UNPushFalse:
807D: 210000  		ld 		hl,0
8080: E5      		push 	hl
8081: DDE9    		jp 		(ix)
8083:         	__UNPushTrue:
8083: 21FFFF  		ld 		hl,0xFFFF
8086:         	__UNPushHLExit	
8086: E5      		push 	hl
8087: DDE9    		jp		(ix)
              	
8089:         	WORD_0LessThan:								; <<0<>>
8089: E1      		pop 	hl
808A: CB7C    		bit 	7,h
808C: 20F5    		jr 		nz,__UNPushTrue
808E: 18ED    		jr 		__UNPushFalse
              	
8090:         	WORD_Abs:									; <<abs>>
8090: E1      		pop 	hl
8091: CB7C    		bit 	7,h 							
8093: 28F1    		jr 		z,__UNPushHLExit 				; if zero push unchanged
8095: E5      		push 	hl
8096: 18D4    		jr	 	WORD_0Minus 					; otherwise do 0-
              	
8098:         	WORD_Sgn:									; <<sgn>>
8098: E1      		pop 	hl
8099: CB7C    		bit 	7,h 							; -ve
809B: 20E6    		jr 		nz,__UNPushTrue
809D: 7C      		ld 		a,h 							; zero
809E: B5      		or 		l
809F: 28DC    		jr 		z,__UNPushFalse
80A1: 210100  		ld 		hl,1 							; +ve push 1
80A4: 18E0    		jr 		__UNPushHLExit
              		
              	; ****************************************************************************************************
              	;
              	;										Arithmetic Quickies
              	;
              	; ****************************************************************************************************
              	
80A6:         	WORD_OnePlus:
80A6: E1      		pop		hl								; <<1+>>
80A7: 1802    		jr 		__OnePlus
              	
80A9:         	WORD_TwoPlus:
80A9: E1      		pop		hl								; <<2+>>
80AA: 23      		inc 	hl
80AB:         	__OnePlus:	
80AB: 23      		inc 	hl
80AC: E5      		push 	hl
80AD: DDE9    		jp 		(ix)
              	
80AF: E1      		pop		hl								; <<1->>
80B0: 1802    		jr 		__OneMinus
              	
80B2: E1      		pop		hl								; <<1->>
80B3: 2B      		dec 	hl
80B4:         	__OneMinus:	
80B4: 2B      		dec 	hl
80B5: E5      		push 	hl
80B6: DDE9    		jp 		(ix)
              	
80B8: E1      		pop		hl 								; <<2*>>
80B9: 1807    		jr 		__TwoTimes
              	
80BB: E1      		pop 	hl								; <<4*>>
80BC: 1803    		jr 		__FourTimes
              	
80BE: E1      		pop		hl 								; <<16*>>
80BF: 29      		add 	hl,hl
80C0: 29      		add 	hl,hl
80C1:         	__FourTimes:
80C1: 29      		add 	hl,hl
80C2:         	__TwoTimes:	
80C2: 29      		add 	hl,hl
80C3: E5      		push 	hl
80C4: DDE9    		jp 		(ix)
              	
80C6: E1      		pop 	hl 								; <<256*>
80C7: 65      		ld	 	h,l
80C8: 2E00    		ld	 	l,0
80CA: E5      		push 	hl
80CB: DDE9    		jp 		(ix)
              	
80CD: E1      		pop 	hl 								; <<2/>>
80CE: 180D    		jr 		__TwoDivide	
              	
80D0: E1      		pop 	hl 								; <<16/>>
              	
80D1: CB2C    		sra 	h
80D3: CB1D    		rr 		l
80D5: CB2C    		sra 	h
80D7: CB1D    		rr 		l
80D9: CB2C    		sra 	h
80DB: CB1D    		rr 		l
              	
80DD:         	__TwoDivide:
80DD: CB2C    		sra 	h
80DF: CB1D    		rr 		l
80E1: E5      		push 	hl
80E2: DDE9    		jp 		(ix)
              	
80E4: E1      		pop 	hl								; <<256/>>
80E5: 6C      		ld	 	l,h
80E6: 2600    		ld 	 	h,0
80E8: CB7D    		bit 	7,l 							; sign extend
80EA: 2801    		jr 		z,__ByteDivideNotSigned
80EC: 25      		dec 	h
80ED:         	__ByteDivideNotSigned: 	
80ED: E5      		push 	hl
80EE: DDE9    		jp 		(ix)
              		include "library/constants.asm"
              	; ****************************************************************************************************
              	;
              	;						Constants, quicker and shorter versions of .literal
              	;
              	; ****************************************************************************************************
              	
              	ConstantWord macro value
              		ld 		hl,&value 						; <<&value>>
              		push 	hl
              		jp 		(ix)
              		endm
              	;
              	;	If you use these (which the compiler does automatically) it saves two bytes over .literal [n]
              	;	and also is several cycles quicker, because it doesn't fetch the value. A similar system is
              	;	used for variables/arrays/constants as these are all 6 bytes long (same as .literal [n] return)
              	;
              		ConstantWord 	-1
80F0: 21FFFF  		ld 		hl,-1 						; <<-1>>
80F3: E5      		push 	hl
80F4: DDE9    		jp 		(ix)
              		ConstantWord 	0	
80F6: 210000  		ld 		hl,0 						; <<0>>
80F9: E5      		push 	hl
80FA: DDE9    		jp 		(ix)
              		ConstantWord 	1
80FC: 210100  		ld 		hl,1 						; <<1>>
80FF: E5      		push 	hl
8100: DDE9    		jp 		(ix)
              		ConstantWord 	2
8102: 210200  		ld 		hl,2 						; <<2>>
8105: E5      		push 	hl
8106: DDE9    		jp 		(ix)
              		ConstantWord 	4
8108: 210400  		ld 		hl,4 						; <<4>>
810B: E5      		push 	hl
810C: DDE9    		jp 		(ix)
              		ConstantWord 	8
810E: 210800  		ld 		hl,8 						; <<8>>
8111: E5      		push 	hl
8112: DDE9    		jp 		(ix)
              		ConstantWord 	10
8114: 210A00  		ld 		hl,10 						; <<10>>
8117: E5      		push 	hl
8118: DDE9    		jp 		(ix)
              		ConstantWord 	16
811A: 211000  		ld 		hl,16 						; <<16>>
811D: E5      		push 	hl
811E: DDE9    		jp 		(ix)
              		ConstantWord 	100
8120: 216400  		ld 		hl,100 						; <<100>>
8123: E5      		push 	hl
8124: DDE9    		jp 		(ix)
              		ConstantWord 	256
8126: 210001  		ld 		hl,256 						; <<256>>
8129: E5      		push 	hl
812A: DDE9    		jp 		(ix)
              	
              		include "library/stack.asm"
              	; ****************************************************************************************************
              	;
              	;										  Stack Manipulation
              	;
              	; ****************************************************************************************************
              	
812C:         	WORD_Dup:									; <<dup>>
812C: E1      		pop 	hl 								; get TOS and push it back twice
812D: E5      		push 	hl
812E: E5      		push 	hl
812F: DDE9    		jp 		(ix) 							; return 
              	
8131:         	WORD_Drop:									; <<drop>>
8131: E1      		pop 	hl
8132: DDE9    		jp 		(ix)
              	
8134:         	WORD_Swap:									; <<swap>>
8134: D9      		exx 									; use alt register set
8135: E1      		pop 	hl 								; get TOS and push it back twice
8136: D1      		pop 	de
8137: E5      		push 	hl
8138: D5      		push 	de
8139: D9      		exx 
813A: DDE9    		jp 		(ix) 							; return 
              	
813C:         	WORD_Over:									; <<over>>
813C: D9      		exx 						
813D: E1      		pop 	hl 								; tos
813E: D1      		pop 	de 								; tos 2
813F: D5      		push 	de 								; push back
8140: E5      		push 	hl
8141: D5      		push 	de 								; with tos 2 on top
8142: D9      		exx
8143: DDE9    		jp 		(ix)
              	
8145:         	WORD_Rot:									; <<rot>>
8145: D9      		exx
8146: E1      		pop 	hl 								; X3  X1 X2 X3 -> X2 X3 X1
8147: D1      		pop 	de 								; X2 
8148: C1      		pop		bc 								; X1
8149: D5      		push 	de
814A: E5      		push 	hl
814B: C5      		push 	bc
814C: D9      		exx
814D: DDE9    		jp 		(ix)
              	
814F:         	WORD_Pick:									; <<pick>>
814F: D9      		exx 		
8150: E1      		pop 	hl 								; get the index off the stack
8151: 39      		add 	hl,sp 							; add stack offset
8152: 56      		ld 		d,(hl) 							; read stack value
8153: 23      		inc 	hl
8154: 5E      		ld 		e,(hl)
8155: D5      		push 	de 								; push on the stack
8156: D9      		exx
8157: DDE9    		jp 		(ix)
              		include "library/misc.asm"
              	; ****************************************************************************************************
              	;
              	; 												Miscellany
              	;
              	; ****************************************************************************************************
              	
              	
8159:         	WORD_Branch:								; <<[br]>>
8159: EB      		ex 	 	de,hl 							; HL now points to the next word
815A: 5E      		ld 		e,(hl)							; read into DE
815B: 23      		inc 	hl
815C: 56      		ld 		d,(hl)
815D: DDE9    		jp 		(ix) 							; and go there.
              	
815F:         	WORD_BranchZero:
815F: E1      		pop 	hl 								; non destructive test of TOS
8160: E5      		push 	hl
8161: 7C      		ld 		a,h 							; branch if zero.
8162: B5      		or 		l
8163: 28F4    		jr 		z,WORD_Branch
8165:         	__WORD_BranchFail:							; if non zero
8165: 13      		inc 	de 								; skip over jump address
8166: 13      		inc 	de
8167: DDE9    		jp 		(ix)
              	
8169:         	WORD_BranchPositive:
8169: E1      		pop 	hl 								; non destructive test of TOS
816A: E5      		push 	hl
816B: CB7C    		bit 	7,h 							; if +ve branch
816D: 28EA    		jr 		z,WORD_Branch
816F: 18F4    		jr 		__WORD_BranchFail 				; if -ve don't
              	
8171:         	WORD_Stop:									; <<stop>>
8171: 18FE    		jr 		WORD_Stop
              	
8173:         	WORD_RStoDS:								; <<r>>>
8173: 0A      		ld 		a,(bc) 							; pop address into HL
8174: 0B      		dec 	bc
8175: 67      		ld 		h,a 
8176: 0A      		ld 		a,(bc)
8177: 0B      		dec 	bc
8178: 6F      		ld 		l,a
8179: E5      		push 	hl 								; push on data stack.
817A: DDE9    		jp 		(ix)
              	
817C:         	WORD_DStoRS:								; <<>r>>
817C: E1      		pop 	hl 								; get top of data stack
817D: 03      		inc 	bc 								; push on return stack.
817E: 7D      		ld 		a,l
817F: 02      		ld 		(bc),a
8180: 03      		inc 	bc
8181: 7C      		ld 		a,h
8182: 02      		ld 		(bc),a
8183: DDE9    		jp 		(ix)
              	
8185:         	WORD_RDrop:									; <<rdrop>>
8185: 0B      		dec 	bc
8186: 0B      		dec 	bc
8187: DDE9    		jp 		(ix)
              		include "library/io.asm"
              	; ****************************************************************************************************
              	;
              	;										Input/Output functions
              	;
              	; ****************************************************************************************************
              	
8189:         	WORD_Emit:									; <<emit>>
8189: E1      		pop 	hl 								; get character to print in L
818A: CDCD81  		call	PrintCharL
818D: DDE9    		jp 		(ix)
              	
818F:         	WORD_PrintInteger:							; <<.>>
818F: E1      		pop 	hl
8190: CD2B82  		call 	PrintInteger
8193: DDE9    		jp 		(ix)
              	
8195:         	WORD_PrintStack:							; <<.stack>>
8195: D5      		push 	de 								; save DE
8196: 210000  		ld 		hl,0  							; get SP into HL
8199: 23      		inc 	hl 								; skip over PUSH DE above
819A: 23      		inc 	hl
819B: 39      		add 	hl,sp
819C: 3E46    		ld  	a,46h 							; first yellow
819E: 328082  		ld 		(__PCAColour),a
81A1:         	__PSLoop:
81A1: 5E      		ld 		e,(hl) 							; load into DE
81A2: 23      		inc 	hl
81A3: 56      		ld 		d,(hl)
81A4: 23      		inc 	hl
81A5: EB      		ex 		de,hl 							; print it
81A6: CD2B82  		call 	PrintInteger
81A9: EB      		ex 		de,hl
81AA: 3E44    		ld  	a,44h 							; remainder green
81AC: 328082  		ld 		(__PCAColour),a
81AF: 7C      		ld 		a,h 							; reached top of stack
81B0: B7      		or 		a
81B1: 20EE    		jr 		nz,__PSLoop
81B3: D1      		pop 	de 								; restore DE
81B4: 2E0D    		ld 		l,13 							; print CR
81B6: CDCD81  		call 	PrintCharL
81B9: DDE9    		jp 		(ix)
              	
81BB:         	WORD_ClearScreen:							; <<cls>>
81BB: CD5282  		call 	ClearScreen
81BE: CD6C82  		call 	HomeCursor
81C1: DDE9    		jp 		(ix)
              	
81C3:         	WORD_CR:									; <<cr>>
81C3: FDE9    		jp 		(iy)
81C5: 2980    		defw 	Core_Literal
81C7: 0D00    		defw 	13
81C9: 8981    		defw 	WORD_Emit
81CB: 3180    		defw 	Core_Return
              	
              	; ****************************************************************************************************
              	;			This is included if io.asm is included, provides direct I/O to Speccy hardware
              	; ****************************************************************************************************
              	
              		include "utils/screen.asm" 				; Screen I/O routines.
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;			Replacement for Spectrums Screen Display Routine, straight 32x24 video display
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	; ****************************************************************************************************
              	;
              	;							Print character in L ; all registers preserved.
              	;
              	; ****************************************************************************************************
              	
81CD:         	PrintCharL:
81CD: F5      		push 	af 								; stack registers
81CE: C5      		push 	bc 								
81CF: D5      		push 	de
81D0: E5      		push 	hl
              	
81D1: 7D      		ld 		a,l 							; check for CR ?
81D2: FE0D    		cp 		13
81D4: 2847    		jr		z,__PCLReturn
              	
81D6: 0600    		ld 		b,0 							; B is the reversing byte
81D8: CB7D    		bit 	7,l 							; if bit 7 set
81DA: 2803    		jr 		z,__PCANotReverse
81DC: 05      		dec 	b 								; B becomes $FF
81DD: CBBD    		res 	7,l 							; drop bit 7
81DF:         	__PCANotReverse:
81DF: 2600    		ld 		h,0 							; HL to 16 bit
81E1: ED5B7A82		ld 		de,(__PCAFont)					; DE = Font Base
81E5: 29      		add 	hl,hl 							; calc Font Base + char * 8
81E6: 29      		add 	hl,hl
81E7: 29      		add 	hl,hl
81E8: 19      		add 	hl,de
81E9: EB      		ex 		de,hl 							; put in DE
81EA: 2A7C82  		ld 		hl,(__PCAVideoPos) 				; get write address
81ED: E5      		push 	hl 								; save for later
81EE:         	_PCALoop:	
81EE: 1A      		ld 		a,(de) 							; read font char
81EF: A8      		xor 	b 								; reverse byte
81F0: 77      		ld 		(hl),a 							; write to screen
81F1: 1C      		inc 	e 								; bump pointers
81F2: 24      		inc 	h
81F3: 7C      		ld 		a,h 							; until done whole row
81F4: E607    		and 	7
81F6: 20F6    		jr 		nz,_PCALoop
              	
              	
81F8: ED5B7E82		ld 		de,(__PCAAttribPos)				; copy colour byte to attribute memory.
81FC: 3A8082  		ld 		a,(__PCAColour)
81FF: 12      		ld 		(de),a
8200: 13      		inc 	de
              	
8201: E1      		pop 	hl 								; restore original video position to HL
8202: 2C      		inc 	l 								; right one
8203: 200C    		jr 		nz,__PCANotNewPage 				; if nz don't need new 1/4k page
8205: 7C      		ld 		a,h 							; advance to next quarter page
8206: C608    		add 	8
8208: 67      		ld 		h,a 	
8209: FE58    		cp 		0x58 							; we only have 3, this is the attribute page
820B: 2004    		jr 		nz,__PCANotNewPage
820D: 2640    		ld 		h,0x40 							; wrap round to top.
820F: 1658    		ld 		d,0x58 							; reset attribute memory pointer
8211:         	__PCANotNewPage:
8211: 227C82  		ld 		(__PCAVideoPos),hl 				; update new position in video / attr
8214: ED537E82		ld 		(__PCAAttribPos),de 			
              	
8218:         	__PCLExit:
8218: E1      		pop 	hl 								; destack.
8219: D1      		pop 	de
821A: C1      		pop 	bc
821B: F1      		pop 	af
821C: C9      		ret
              	
821D:         	__PCLReturn: 								; carriage return.
821D: 2E20    		ld 		l,' '
821F: CDCD81  		call 	PrintCharL
8222: 3A7C82  		ld 		a,(__PCAVideoPos)
8225: E61F    		and 	31
8227: 20F4    		jr 		nz,__PCLReturn
8229: 18ED    		jr 		__PCLExit
              	
              	; ****************************************************************************************************
              	;
              	;									Print HL in hexadecimal
              	;
              	; ****************************************************************************************************
              	
822B:         	PrintInteger:
822B: E5      		push 	hl
822C: 2E20    		ld 		l,' ' 							; print leading space
822E: CDCD81  		call 	PrintCharL
8231: E1      		pop 	hl
8232: 7C      		ld 		a,h
8233: CD3B82  		call 	PrintByteA
8236: 7D      		ld 		a,l
8237: CD3B82  		call 	PrintByteA
823A: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;									Print Byte in Hexadecimal
              	;
              	; ****************************************************************************************************
              	
823B:         	PrintByteA:
823B: F5      		push 	af 								; save A on stack
823C: 1F      		rra 									; shift right 4
823D: 1F      		rra
823E: 1F      		rra
823F: 1F      		rra
8240: CD4482  		call	__PBANibble 					; print it
8243: F1      		pop 	af 								; restore
8244:         	__PBANibble:
8244: F6F0    		or 		0F0h 							; DAA trick
8246: 27      		daa
8247: C6A0    		add 	a,0A0h
8249: CE40    		adc 	a,040h
824B: E5      		push 	hl 								; print character
824C: 6F      		ld 		l,a
824D: CDCD81  		call 	PrintCharL
8250: E1      		pop 	hl
8251: C9      		ret
              	
              	; ****************************************************************************************************
              	;	
              	;											Clear Screen
              	;
              	; ****************************************************************************************************
              	
8252:         	ClearScreen:
8252: E5      		push 	hl
8253: 210040  		ld 		hl,0x4000 						; fill 4000-57FF with zero
8256:         	__CLSLoop1:
8256: 3600    		ld 		(hl),0
8258: 23      		inc 	hl
8259: 7C      		ld 		a,h
825A: FE58    		cp 		0x58
825C: 20F8    		jr		nz,__CLSLoop1
825E:         	__CLSLoop2:									; fill 5800-5FFF with 7 (white)
825E: 3607    		ld 		(hl),7
8260: 23      		inc 	hl
8261: 7C      		ld 		a,h
8262: FE60    		cp 		0x60
8264: 20F8    		jr		nz,__CLSLoop2
8266: 3E01    		ld 		a,1 							; set border to blue.
8268: D3FE    		out 	(0xFE),a
826A: E1      		pop 	hl
826B: C9      		ret
              	
              	; ****************************************************************************************************
              	;
              	;												Home Cursor
              	;
              	; ****************************************************************************************************
              	
826C:         	HomeCursor:	
826C: E5      		push 	hl
826D: 210058  		ld 		hl,0x5800 						; reset attribute pos
8270: 227E82  		ld 		(__PCAAttribPos),hl
8273: 2640    		ld 		h,0x40 							; reset video pos
8275: 227C82  		ld 		(__PCAVideoPos),hl
8278: E1      		pop 	hl
8279: C9      		ret
              	
827A:         	__PCAFont: 									; font base here
827A: 003C    		defw 	0x3C00
827C:         	__PCAVideoPos: 								; current video memory pointer.
827C: 0040    		defw 	VideoMemory
827E:         	__PCAAttribPos:								; current attribute pointer
827E: 0058    		defw 	AttributeMemory
8280:         	__PCAColour: 								; current colour to use
8280: 44      		defb 	0x44
              		include "library/utils/sprites.asm"
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	;
              	;										16x16 Sprite Routines
              	;
              	; ****************************************************************************************************
              	; ****************************************************************************************************
              	
              	;
              	;	+0 			X position
              	;	+1 			Y position
              	;	+2 			Vertical Size (bits 0..6)
              	;	+3 			Drawing color (0 = don't do attribute)
              	;	+4,5 		pointer to 16 bit pixel data 
              	;	+6,7 		either 0 (not back stored) or pointer to background storage (pointer + 3 x vertical size)
              	;	+8,9 		either 0 (no mask data) or pointer to mask data, note set to clear background.
              	;
              	
8281:         	DrawSprite:
8281: DD211C83		ld 		ix,testSprite
              	
              	
              	; ****************************************************************************************************
              	;					Set up the pixel shifter for the 3 LSB of the x coordinate
              	; ****************************************************************************************************
              	
8285: DD7E00  		ld 		a,(ix+0) 						; x 0-7 pixels
8288: E607    		and 	7
828A: 2804    		jr 		z,__DSOffsetDone 				; if zero, the JR will just fall through to register move
828C: 3D      		dec 	a
828D: 87      		add 	a,a	
828E: C605    		add 	__DSShiftEntry-__DSShiftAHL-2
8290:         	__DSOffsetDone:
8290: 320783  		ld 		(__DSShiftAHL+1),a 				; set the JR offset.
              	
              	
8293: 2AAF82  		ld 		hl,(__DSLoadScreenAddress+1)
8296: 25      		dec		h 								; temp for checking.
8297: 25      		dec 	h
8298: 36FF    		ld 		(hl),$FF
              	
829A:         	__DSMainLoop:
              	;
              	;	Copy to backstorage [TODO]
              	;
              	
              	; ****************************************************************************************************
              	;						Mask the graphic mask onto the screen, if it is in use
              	; ****************************************************************************************************
829A:         	__DSLoadMaskAddress:
829A: 214C83  		ld 		hl,maskData 					; mask data address
829D: 7C      		ld 		a,h
829E: B5      		or 		l 								; if mask address is zero, then don't do the mask.
829F: 281D    		jr 		z,__DSXorGraphic
              	
82A1: 56      		ld 		d,(hl) 							; read mask into DE
82A2: 23      		inc 	hl
82A3: 5E      		ld 		e,(hl)
82A4: 23      		inc 	hl
82A5: 229B82  		ld 		(__DSLoadMaskAddress+1),hl 		; update the mask data address
82A8: EB      		ex 		de,hl 							; 16 bit now in HL.
82A9: AF      		xor  	a 								; 24 bit graphic in AHL
82AA: CD0683  		call 	__DSShiftAHL					; shift it accordingly
82AD: EB      		ex 		de,hl 							; now it is in ADE
82AE:         	__DSLoadScreenAddress:
82AE: 21124A  		ld 		hl,4A12h						; where we will mask
              	
82B1: 2F      		cpl 									; mask the ADE bytes - 1's complement each and AND into screen
82B2: A6      		and		(hl)
82B3: 77      		ld 		(hl),a
82B4: 2C      		inc 	l
82B5: 7A      		ld 		a,d
82B6: 2F      		cpl
82B7: A6      		and		(hl)
82B8: 77      		ld 		(hl),a
82B9: 2C      		inc 	l
82BA: 7B      		ld 		a,e
82BB: 2F      		cpl
82BC: A6      		and 	(hl)
82BD: 77      		ld 		(hl),a
              	
              	
              	; ****************************************************************************************************
              	;								XOR the graphic data into the screen
              	; ****************************************************************************************************
82BE:         	__DSXorGraphic:
              	
82BE:         	__DSLoadGraphicData:
82BE: 213883  		ld 		hl,graphicData 					; pointer to graphic data (modified in-line)
82C1: 56      		ld 		d,(hl) 							; read into DE
82C2: 23      		inc 	hl
82C3: 5E      		ld 		e,(hl)
82C4: 23      		inc 	hl
82C5: 22BF82  		ld 		(__DSLoadGraphicData+1),hl 		; update graphic data pointer
              	
82C8: EB      		ex 		de,hl 							; 16 bit now in HL.
82C9: AF      		xor  	a 								; 24 bit graphic in AHL
              	
82CA: CD0683  		call 	__DSShiftAHL					; shift it accordingly
              	
82CD: EB      		ex 		de,hl 							; now it is in ADE
82CE: 2AAF82  		ld 		hl,(__DSLoadScreenAddress+1) 	; HL is where it is XORed into.
              	
82D1: AE      		xor 	(hl) 							; XOR those three bytes in.
82D2: 77      		ld 		(hl),a
82D3: 2C      		inc 	l
82D4: 7A      		ld 		a,d
82D5: AE      		xor 	(hl)
82D6: 77      		ld 		(hl),a
82D7: 2C      		inc 	l
82D8: 7B      		ld 		a,e
82D9: AE      		xor 	(hl)
82DA: 77      		ld 		(hl),a
82DB: 2D      		dec 	l 								; unpick the increment
82DC: 2D      		dec 	l
              	;
              	;	Move to the next line down
              	;
82DD: CDF382  		call 	__DSHLDown 						; HL Down one line
82E0: 7C      		ld 		a,h
82E1: FE58    		cp 		58h								; into attribute memory ?
82E3: 280B    		jr 		z,__DSExitEarly 				; off bottom of screen, end of sprite draw
              	
82E5:         	__DSNoOverflowScreen1
82E5: 22AF82  		ld 		(__DSLoadScreenAddress+1),hl 	; update the screen address.
              	
82E8:         	__DSLoadVerticalCount:
82E8: 3E0A    		ld 		a,10 							; count of lines to do
82EA: 3D      		dec 	a 								; decrement and update
82EB: 32E982  		ld 		(__DSLoadVerticalCount+1),a 	
82EE: 20AA    		jr 		nz,__DSMainLoop 				; keep going till done all lines, or reached the end of screen memory
82F0:         	__DSExitEarly:
              	
              	
82F0:         	Stop:
82F0: 18FE    		jr 		Stop
82F2: C9      		ret
              	
              	;
              	;	Advance the line down by 1, handles the slightly odd screen arrangement
              	;
82F3:         	__DSHLDown:
82F3: 24      		inc 	h 								; next line down.
82F4: 7C      		ld 		a,h 							; have we stepped over the border
82F5: E607    		and 	7
82F7: C0      		ret 	nz
              	
82F8: 7C      		ld 		a,h 							; fix up three lower bits of high address byte
82F9: D608    		sub 	8
82FB: 67      		ld 		h,a
              	
82FC: 7D      		ld 		a,l 							; next block of 8 down, high 3 bits of low address byte
82FD: C620    		add 	32
82FF: 6F      		ld 		l,a
8300: D0      		ret		nc
              	
8301: 7C      		ld 		a,h 							; next page down.
8302: C608    		add 	8
8304: 67      		ld 		h,a
8305: C9      		ret
              	;
              	;	Shift the 24 bit value AHL left a number of times defined by the x coordinate
              	;
8306:         	__DSShiftAHL:
8306: 1805    		jr 		__DSShiftEntry
8308: 7C      		ld 		a,h
8309: 65      		ld 		h,l
830A: 2E00    		ld 		l,0
830C: C9      		ret
              	
830D:         	__DSShiftEntry:
830D: 29      		add 	hl,hl 							; the JR at __DSShiftEntry jumps into this code.
830E: 8F      		adc 	a,a
830F: 29      		add 	hl,hl
8310: 8F      		adc 	a,a
8311: 29      		add 	hl,hl
8312: 8F      		adc 	a,a
8313: 29      		add 	hl,hl
8314: 8F      		adc 	a,a
              	
8315: 29      		add 	hl,hl
8316: 8F      		adc 	a,a
8317: 29      		add 	hl,hl
8318: 8F      		adc 	a,a
8319: 29      		add 	hl,hl
831A: 8F      		adc 	a,a
831B: C9      		ret
              	
831C:         	testSprite:
831C: 07      		defb 	7
831D: 04      		defb 	4
831E: 08      		defb 	8
831F: 08      		defb 	8
              	
8320:         	backStore:
8320: 00000000		defs 	8*3
8324: 00...   	
              	
8338:         	graphicData:
8338: FFFF    		defb 	0FFh,0FFh
833A: 8001    		defb 	080h,001h
833C: 8003    		defb 	080h,003h
833E: 8007    		defb 	080h,007h
8340: 8F0F    		defb 	08Fh,00Fh
8342: 801F    		defb 	080h,01Fh
8344: FFE0    		defb 	0FFh,0E0h
8346: 0200    		defb 	002h,000h
8348: 0200    		defb 	002h,000h
834A: 0700    		defb 	007h,000h
              	
834C:         	maskData:
834C: 0180    		defb 	001h,080h
834E: 03C0    		defb 	003h,0C0h
8350: 07E0    		defb 	007h,0E0h
8352: 0FF0    		defb 	00Fh,0F0h
8354: 1FF8    		defb 	01Fh,0F8h
8356: 3FFC    		defb 	03Fh,0FCh
8358: 7FFE    		defb 	07Fh,0FEh
835A: FFFF    		defb 	0FFh,0FFh
835C: 0180    		defb 	001h,080h
835E: FFFF    		defb 	0FFh,0FFh
              	
8360:         	BootWord:
8360: FDE9    		jp 			(iy)
8362: BB81    		defw 		WORD_ClearScreen
8364: 7583    		defw 		WORD_Star
8366: 6C83    		defw 		Test
8368: 7583    		defw 		WORD_Star
836A: 7181    		defw 		WORD_Stop
              	
836C:         	Test:
836C: DDE5    		push 		ix
836E: CD8182  		call 		DrawSprite
8371: DDE1    		pop 		ix
8373: DDE9    		jp 			(ix)
              	
8375:         	WORD_Star:
8375: FDE9    		jp 			(iy)
8377: 2980    		defw 		Core_Literal
8379: 2A00    		defw 		42
837B: 8981    		defw 		WORD_Emit
837D: 3180    		defw 		Core_Return
              	
837F:         	EndOfCode:
              	
              	; ****************************************************************************************************
              	;
              	;												Examples
              	;
              	; ****************************************************************************************************
              	
              	;
              	;	Code word (example) DUP. Note that in code words DE is the code pointer.
              	;	We just go straight in with the machine code. Code words can only use HL as a temporary value
              	; 	so for things like + use EXX and do it in the alternate set.
              	;
              	;
              	;dup:										; <<dup>>
              	;	pop 	hl
              	;	push 	hl
              	;	push 	hl
              	;	jp		(ix)							; and fix up so HL is the code pointer again and loop
              	;
              	;
              	;
              	;	Word built up out of other definitions.
              	;	
              	;	jp 		(iy)							; identifies as a word from words.
              	;
              	;	; first def addr
              	;	; second def addr
              	;	;	..
              	;	;	..
              	;
              	;	defw 	Core_Return 					; now we want to go back.
              	;
              	
              	
              	


total time: 0.0019 sec.
no errors
